{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./tests/tests.js"],"names":["describe","it","expect","toBe"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;AClFA;AACA;AAEAA,QAAQ,CAAC,UAAD,EAAa,YAAM;AACzBC,IAAE,CAAC,UAAD,EAAa,YAAM;AACnBC,UAAM,CAAC,CAAD,CAAN,CAAUC,IAAV,CAAe,CAAf;AACD,GAFC,CAAF;AAGD,CAJO,CAAR,C,CAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA,M","file":"tests.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","// import emitter from \"component-emitter\";\n// import promisify from \"promisify-function\"; // eslint-disable-line import/no-extraneous-dependencies\n\ndescribe(\"DISABLED\", () => {\n  it(\"DISABLED\", () => {\n    expect(1).toBe(1);\n  });\n});\n\n// /* global feedmeClient */\n// /*\n\n// Build integration/functional tests run on Node and in the browser.\n// Assume an in-scope feedmeClient() factory function.\n\n// Tests API promises in the user documentation, ensures that the client\n// interacts appropriately with the transport, and ensures that messages\n// send via the transport abide by the Feedme spec.\n\n// 1. Do configuration options work as documented?\n// 2. Do app-initiated operations work as documented?\n// 3. Do transport-initiated operations work as documented?\n\n// There is no access to external modules (also runs in the browser), so\n// basic event emitter functionality for the transport is included inline.\n\n// */\n// const epsilon = 1;\n\n// const harnessProto = {};\n// const harnessFactory = options => {\n//   // Mock transport is added to any other specified options\n//   options = options || {}; // eslint-disable-line no-param-reassign\n//   const harness = Object.create(harnessProto);\n\n//   // Create the transport basics\n//   // Have it emit events asynchronously, as required of the transport\n//   const t = emitter({});\n//   const { emit } = t;\n//   t.emit = (...args) => {\n//     process.nextTick(emit.bind(t), ...args);\n//   };\n//   harness.transport = t;\n//   options.transport = t; // eslint-disable-line no-param-reassign\n\n//   // Transport spies\n//   t.connect = jasmine.createSpy();\n//   t.send = jasmine.createSpy();\n//   t.disconnect = jasmine.createSpy();\n//   t.state = jasmine.createSpy();\n//   t.state.and.returnValue(\"disconnected\");\n//   t.spyClear = () => {\n//     t.connect.calls.reset();\n//     t.send.calls.reset();\n//     t.disconnect.calls.reset();\n//     t.state.calls.reset();\n//   };\n\n//   // Create the client\n//   harness.client = feedmeClient(options);\n\n//   return harness;\n// };\n\n// harnessProto.createClientListener = function createClientListener() {\n//   const l = {\n//     connecting: jasmine.createSpy(),\n//     connect: jasmine.createSpy(),\n//     disconnect: jasmine.createSpy(),\n//     badServerMessage: jasmine.createSpy(),\n//     badClientMessage: jasmine.createSpy(),\n//     transportError: jasmine.createSpy()\n//   };\n//   l.spyClear = () => {\n//     l.connecting.calls.reset();\n//     l.connect.calls.reset();\n//     l.disconnect.calls.reset();\n//     l.badServerMessage.calls.reset();\n//     l.badClientMessage.calls.reset();\n//     l.transportError.calls.reset();\n//   };\n//   this.client.on(\"connecting\", l.connecting);\n//   this.client.on(\"connect\", l.connect);\n//   this.client.on(\"disconnect\", l.disconnect);\n//   this.client.on(\"badServerMessage\", l.badServerMessage);\n//   this.client.on(\"badClientMessage\", l.badClientMessage);\n//   this.client.on(\"transportError\", l.transportError);\n//   return l;\n// };\n\n// harnessProto.createFeedListener = function createFeedListener(feed) {\n//   const l = {\n//     opening: jasmine.createSpy(),\n//     open: jasmine.createSpy(),\n//     close: jasmine.createSpy(),\n//     action: jasmine.createSpy()\n//   };\n//   l.spyClear = () => {\n//     l.opening.calls.reset();\n//     l.open.calls.reset();\n//     l.close.calls.reset();\n//     l.action.calls.reset();\n//   };\n//   feed.on(\"opening\", l.opening);\n//   feed.on(\"open\", l.open);\n//   feed.on(\"close\", l.close);\n//   feed.on(\"action\", l.action);\n//   return l;\n// };\n\n// harnessProto.connectClient = async function connectClient() {\n//   this.client.connect();\n//   this.transport.state.and.returnValue(\"connecting\");\n//   this.transport.emit(\"connecting\");\n//   this.transport.state.and.returnValue(\"connected\");\n//   this.transport.emit(\"connect\");\n//   this.transport.emit(\n//     \"message\",\n//     JSON.stringify({\n//       MessageType: \"HandshakeResponse\",\n//       Success: true,\n//       Version: \"0.1\",\n//       ClientId: \"SOME_CLIENT_ID\"\n//     })\n//   );\n\n//   await promisify(process.nextTick)();\n// };\n\n// /*\n\n// Configuration tests and associated functionality.\n// Ensure that initialization options behave as documented.\n\n// */\n\n// describe(\"The connectTimeoutMs option\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if greater than zero, should time out appropriately\", () => {\n//     const opts = {\n//       connectTimeoutMs: 1000\n//     };\n//     const harness = harnessFactory(opts);\n//     const clientListener = harness.createClientListener();\n\n//     // Begin connection attempt\n//     harness.client.connect();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n\n//     // Advance to immediately before the timeout and verify that\n//     // transport.disconnect() was not called\n//     harness.transport.spyClear();\n//     jasmine.clock().tick(opts.connectTimeoutMs - epsilon);\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     expect(harness.transport.state.calls.count()).toBe(0);\n\n//     // Advance to immediately after the timeout and ensure that\n//     // transport.disconnect() was called\n//     harness.transport.spyClear();\n//     jasmine.clock().tick(2 * epsilon);\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(1);\n//     for (let i = 0; i < harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n\n//     // Emit transport disconnect and check the client disconnect event\n//     clientListener.spyClear();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"TIMEOUT: ...\"));\n//     expect(clientListener.connecting.calls.count()).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(1);\n//     expect(clientListener.disconnect.calls.argsFor(0).length).toBe(1);\n//     expect(clientListener.disconnect.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(clientListener.disconnect.calls.argsFor(0)[0].message).toBe(\n//       \"TIMEOUT: ...\"\n//     );\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//     expect(clientListener.transportError.calls.count()).toBe(0);\n//   });\n\n//   it(\"if zero, should never time out\", () => {\n//     const opts = {\n//       connectTimeoutMs: 0\n//     };\n//     const harness = harnessFactory(opts);\n//     const clientListener = harness.createClientListener();\n\n//     // Begin connection attempt\n//     harness.client.connect();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n\n//     // Advance to the end of time and verify that transport.disconnect() was not called\n//     harness.transport.spyClear();\n//     jasmine.clock().tick(Number.MAX_SAFE_INTEGER);\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     expect(harness.transport.state.calls.count()).toBe(0);\n\n//     // Ensure that the disconnect event was not emitted\n//     clientListener.spyClear();\n//     expect(clientListener.connecting.calls.count()).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(0);\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//     expect(clientListener.transportError.calls.count()).toBe(0);\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The connectRetryMs option\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if greater than zero, should wait appropriately between connection retries\", () => {\n//     const opts = {\n//       connectRetryMs: 1000\n//     };\n//     const harness = harnessFactory(opts);\n//     const clientListener = harness.createClientListener();\n\n//     // Begin connection attempt and have it fail\n//     harness.client.connect();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//     // Advance to immediately before the retry and verify that\n//     // transport.connect() was not called\n//     harness.transport.spyClear();\n//     jasmine.clock().tick(opts.connectRetryMs - epsilon);\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     expect(harness.transport.state.calls.count()).toBe(0);\n\n//     // Advance to immediately after the retry and ensure that\n//     // transport.connect() was called\n//     harness.transport.spyClear();\n//     jasmine.clock().tick(2 * epsilon);\n//     expect(harness.transport.connect.calls.count()).toBe(1);\n//     expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     for (let i = 0; i < harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n\n//     // Emit transport connecting and check the client connecting event\n//     clientListener.spyClear();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n//     expect(clientListener.connecting.calls.count()).toBe(1);\n//     expect(clientListener.connecting.calls.argsFor(0).length).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(0);\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//     expect(clientListener.transportError.calls.count()).toBe(0);\n//   });\n\n//   it(\"if zero, should immediately attempt a connection retry\", () => {\n//     const opts = {\n//       connectRetryMs: 0\n//     };\n//     const harness = harnessFactory(opts);\n//     const clientListener = harness.createClientListener();\n\n//     // Begin connection attempt\n//     harness.client.connect();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n\n//     // Have the connection attempt fail, and verify that there is an\n//     // immediate call to transport.connect()\n//     harness.transport.spyClear();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n//     jasmine.clock().tick(0); // The retry is async\n//     expect(harness.transport.connect.calls.count()).toBe(1);\n//     expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     for (let i = 0; i < harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n\n//     // Emit transport connecting and check the client connecting event\n//     clientListener.spyClear();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n//     expect(clientListener.connecting.calls.count()).toBe(1);\n//     expect(clientListener.connecting.calls.argsFor(0).length).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(0);\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//     expect(clientListener.transportError.calls.count()).toBe(0);\n//   });\n\n//   it(\"if less than zero, should not attempt a connection retry\", () => {\n//     const opts = {\n//       connectRetryMs: -1\n//     };\n//     const harness = harnessFactory(opts);\n//     const clientListener = harness.createClientListener();\n\n//     // Begin connection attempt\n//     harness.client.connect();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n\n//     // Have the connection attempt fail and verify that there is no subsequent\n//     // call to transport.connect()\n//     harness.transport.spyClear();\n//     clientListener.spyClear();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n//     jasmine.clock().tick(Number.MAX_SAFE_INTEGER);\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     for (let i = 0; i < harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n//   });\n\n//   it(\"should not attempt a reconnect on HANDSHAKE_REJECTED failure\", () => {\n//     const opts = {\n//       connectRetryMs: 1000\n//     };\n//     const harness = harnessFactory(opts);\n\n//     // Connect the transport\n//     harness.client.connect();\n//     harness.transport.state.and.returnValue(\"connecting\");\n//     harness.transport.emit(\"connecting\");\n//     harness.transport.state.and.returnValue(\"connected\");\n//     harness.transport.emit(\"connect\");\n\n//     // Have the trensport reject the handshake and verify that there is\n//     // a subsequent call to transport.disconnect(err) and no call to\n//     // transport.connect()\n//     harness.transport.spyClear();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"HandshakeResponse\",\n//         Success: false\n//       })\n//     );\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(1);\n//     expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(1);\n//     expect(harness.transport.disconnect.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(harness.transport.disconnect.calls.argsFor(0)[0].message).toBe(\n//       \"HANDSHAKE_REJECTED: The server rejected the handshake.\"\n//     );\n//     for (let i = 0; i <= harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n\n//     // Emit transport disconnect, advance forever, and check that\n//     // transport.connect() is never called\n//     harness.transport.spyClear();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\n//       \"disconnect\",\n//       new Error(\"HANDSHAKE_REJECTED: The server rejected the handshake.\")\n//     );\n//     jasmine.clock().tick(Number.MAX_SAFE_INTEGER);\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     for (let i = 0; i <= harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The connectRetryBackoffMs and connectRetryMaxMs options\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"should back off as configured\", () => {\n//     const opts = {\n//       connectRetryMs: 1000,\n//       connectRetryBackoffMs: 1000,\n//       connectRetryMaxMs: 10000\n//     };\n//     const harness = harnessFactory(opts);\n\n//     // Run a bunch of retries\n//     harness.client.connect();\n//     for (let i = 0; i < 20; i += 1) {\n//       // How long should it wait?\n//       const ms = Math.min(\n//         opts.connectRetryMs + i * opts.connectRetryBackoffMs,\n//         opts.connectRetryMaxMs\n//       );\n\n//       // Begin connection attempt and have it fail\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//       // Advance to immediately before the retry and verify that\n//       // transport.connect() was not called\n//       harness.transport.spyClear();\n//       jasmine.clock().tick(ms - epsilon);\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count()).toBe(0);\n\n//       // Advance to immediately after the retry and ensure that\n//       // transport.connect() was called\n//       harness.transport.spyClear();\n//       jasmine.clock().tick(2 * epsilon);\n//       expect(harness.transport.connect.calls.count()).toBe(1);\n//       expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       for (let j = 0; j < harness.transport.state.calls.count(); j += 1) {\n//         expect(harness.transport.state.calls.argsFor(j).length).toBe(0);\n//       }\n//     }\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The connectRetryMaxAttempts option\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if greater than zero, should stop connection retries as configured\", () => {\n//     const opts = {\n//       connectRetryMs: 0,\n//       connectRetryBackoffMs: 0,\n//       connectRetryMaxAttempts: 10\n//     };\n//     const harness = harnessFactory(opts);\n\n//     // Run a bunch of retries\n//     harness.client.connect();\n//     for (let i = 0; i <= opts.connectRetryMaxAttempts; i += 1) {\n//       // Begin connection attempt and have it fail\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//       // Advance to immediately after the retry and ensure that\n//       // transport.connect() was called if fewer than max retries and\n//       // not called otherwise\n//       harness.transport.spyClear();\n//       jasmine.clock().tick(0); // async\n//       if (i < opts.connectRetryMaxAttempts) {\n//         expect(harness.transport.connect.calls.count()).toBe(1);\n//         expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//       } else {\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//       }\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       for (let j = 0; j < harness.transport.state.calls.count(); j += 1) {\n//         expect(harness.transport.state.calls.argsFor(j).length).toBe(0);\n//       }\n//     }\n//   });\n\n//   it(\"if zero, should always make connection retries\", () => {\n//     const opts = {\n//       connectRetryMs: 0,\n//       connectRetryBackoffMs: 0,\n//       connectRetryMaxAttempts: 0\n//     };\n//     const harness = harnessFactory(opts);\n\n//     // Run a bunch of retries\n//     harness.client.connect();\n//     for (let i = 0; i <= 100; i += 1) {\n//       // Begin connection attempt and have it fail\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//       // Advance to immediately after the retry and ensure that\n//       // transport.connect() was called\n//       harness.transport.spyClear();\n//       jasmine.clock().tick(0); // async\n//       expect(harness.transport.connect.calls.count()).toBe(1);\n//       expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       for (let j = 0; j < harness.transport.state.calls.count(); j += 1) {\n//         expect(harness.transport.state.calls.argsFor(j).length).toBe(0);\n//       }\n//     }\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The actionTimeoutMs option\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if greater than zero, should timeout as configured\", async () => {\n//     const opts = {\n//       actionTimeoutMs: 1000\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Invoke the action\n//     const cb = jasmine.createSpy();\n//     const cbLate = jasmine.createSpy();\n//     harness.client.action(\"SomeAction\", { Some: \"Args\" }, cb, cbLate);\n\n//     // Advance to immediately before the timeout and ensure that\n//     // neither callback was called\n//     jasmine.clock().tick(opts.actionTimeoutMs - epsilon);\n//     expect(cb.calls.count()).toBe(0);\n//     expect(cbLate.calls.count()).toBe(0);\n\n//     // Advance to immediately after the timeout and ensure that cb was called\n//     jasmine.clock().tick(2 * epsilon);\n//     expect(cb.calls.count()).toBe(1);\n//     expect(cb.calls.argsFor(0).length).toBe(1);\n//     expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//     expect(cb.calls.argsFor(0)[0].message).toBe(\n//       \"TIMEOUT: The server did not respond within the allocated time.\"\n//     );\n//     expect(cbLate.calls.count()).toBe(0);\n//   });\n\n//   it(\"if zero, should never timeout\", async () => {\n//     const opts = {\n//       actionTimeoutMs: 0\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Invoke the action\n//     const cb = jasmine.createSpy();\n//     const cbLate = jasmine.createSpy();\n//     harness.client.action(\"SomeAction\", { Some: \"Args\" }, cb, cbLate);\n\n//     // Advance to the end of time and ensure no callbacks\n//     jasmine.clock().tick(Number.MAX_SAFE_INTEGER);\n//     expect(cb.calls.count()).toBe(0);\n//     expect(cbLate.calls.count()).toBe(0);\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The feedTimeoutMs option\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if greater than zero, should timeout as configured\", async () => {\n//     const opts = {\n//       feedTimeoutMs: 1000\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Ask to open the feed\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Args\" });\n//     feed.desireOpen();\n\n//     await promisify(process.nextTick)(); // Move past queued events\n\n//     // Advance to immediately before the timeout and ensure that no events have fired\n//     const feedListener = harness.createFeedListener(feed);\n//     jasmine.clock().tick(opts.feedTimeoutMs - epsilon);\n\n//     await promisify(process.nextTick)();\n\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n\n//     // Advance to immediately after the timeout and ensure that close was fired\n//     jasmine.clock().tick(2 * epsilon);\n\n//     await promisify(process.nextTick)();\n\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(1);\n//     expect(feedListener.close.calls.argsFor(0).length).toBe(1);\n//     expect(feedListener.close.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//     expect(feedListener.close.calls.argsFor(0)[0].message).toBe(\n//       \"TIMEOUT: The server did not respond to feed open request within the allocated time.\"\n//     );\n//     expect(feedListener.action.calls.count()).toBe(0);\n//   });\n\n//   it(\"if zero, should never timeout\", async () => {\n//     const opts = {\n//       feedTimeoutMs: 0\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Ask to open the feed\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Args\" });\n//     feed.desireOpen();\n\n//     // Advance to the end of time and ensure that no events have fired\n//     const feedListener = harness.createFeedListener(feed);\n//     jasmine.clock().tick(Math.MAX_SAFE_INTEGER);\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The reconnect option\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if true, should reconnect if the connection fails\", async () => {\n//     const opts = {\n//       reconnect: true\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Disconnect the transport and ensure that transport.connect() is called\n//     harness.transport.spyClear();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n//     expect(harness.transport.connect.calls.count()).toBe(1);\n//     expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     for (let i = 0; i < harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n//   });\n\n//   it(\"if false, should not reconnect if the connection fails\", async () => {\n//     const opts = {\n//       reconnect: false\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Disconnect the transport and ensure that transport.connect() is not called\n//     harness.transport.spyClear();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n//     expect(harness.transport.connect.calls.count()).toBe(0);\n//     expect(harness.transport.send.calls.count()).toBe(0);\n//     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//     for (let i = 0; i < harness.transport.state.calls.count(); i += 1) {\n//       expect(harness.transport.state.calls.argsFor(i).length).toBe(0);\n//     }\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The reopenMaxAttempts and reopenTrailingMs options\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   it(\"if reopenMaxAttempts is negative, should always try to re-open the feed\", async () => {\n//     const opts = {\n//       reopenMaxAttempts: -1\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Open the feed\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Args\" });\n//     feed.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: true,\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedData: {}\n//       })\n//     );\n\n//     const feedListener = harness.createFeedListener(feed);\n//     for (let i = 0; i < 20; i += 1) {\n//       // Move past queued events\n//       await promisify(process.nextTick)(); // eslint-disable-line no-await-in-loop\n\n//       feedListener.spyClear();\n\n//       // Transmit a bad action revelation; the session will ask to close the feed\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionRevelation\",\n//           ActionName: \"SomeAction\",\n//           ActionData: {},\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" },\n//           FeedDeltas: [{ Path: [], Operation: \"Delete\" }]\n//         })\n//       );\n\n//       // Check that the feed is re-opened on success\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" }\n//         })\n//       );\n\n//       await promisify(process.nextTick)(); // eslint-disable-line no-await-in-loop\n\n//       expect(feedListener.opening.calls.count()).toBe(1);\n//       expect(feedListener.opening.calls.argsFor(0).length).toBe(0);\n//       expect(feedListener.open.calls.count()).toBe(0);\n//       expect(feedListener.close.calls.count()).toBe(1);\n//       expect(feedListener.close.calls.argsFor(0).length).toBe(1);\n//       expect(feedListener.close.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(feedListener.close.calls.argsFor(0)[0].message).toBe(\n//         \"BAD_ACTION_REVELATION: The server passed an invalid feed delta.\"\n//       );\n//       expect(feedListener.action.calls.count()).toBe(0);\n\n//       // Successfully re-open the feed\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" },\n//           FeedData: {}\n//         })\n//       );\n//     }\n//   });\n\n//   it(\"if reopenMaxAttempts is zero, should not try to re-open the feed\", async () => {\n//     const opts = {\n//       reopenMaxAttempts: 0\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Open the feed\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Args\" });\n//     feed.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: true,\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedData: {}\n//       })\n//     );\n\n//     await promisify(process.nextTick)(); // Move past queued events\n\n//     const feedListener = harness.createFeedListener(feed);\n\n//     // Transmit a bad action revelation; the session will ask to close the feed\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"ActionRevelation\",\n//         ActionName: \"SomeAction\",\n//         ActionData: {},\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedDeltas: [{ Path: [], Operation: \"Delete\" }]\n//       })\n//     );\n\n//     // Check that the feed is not re-opened on success\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedCloseResponse\",\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" }\n//       })\n//     );\n\n//     await promisify(process.nextTick)();\n\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(1);\n//     expect(feedListener.close.calls.argsFor(0).length).toBe(1);\n//     expect(feedListener.close.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//     expect(feedListener.close.calls.argsFor(0)[0].message).toBe(\n//       \"BAD_ACTION_REVELATION: The server passed an invalid feed delta.\"\n//     );\n//     expect(feedListener.action.calls.count()).toBe(0);\n//   });\n\n//   it(\"if reopenMaxAttempts is positive and reopenTrailingMs is positive, should respect that limit\", async () => {\n//     const opts = {\n//       reopenMaxAttempts: 5,\n//       reopenTrailingMs: 1000\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Open the feed\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Args\" });\n//     feed.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: true,\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedData: {}\n//       })\n//     );\n\n//     // Have the feed fail reopenMaxAttempts times\n//     const feedListener = harness.createFeedListener(feed);\n//     for (let i = 0; i < opts.reopenMaxAttempts; i += 1) {\n//       // Transmit a bad action revelation; the session will ask to close the feed\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionRevelation\",\n//           ActionName: \"SomeAction\",\n//           ActionData: {},\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" },\n//           FeedDeltas: [{ Path: [], Operation: \"Delete\" }]\n//         })\n//       );\n\n//       // Move past queued events\n//       await promisify(process.nextTick)(); // eslint-disable-line no-await-in-loop\n\n//       // Check that the feed is re-opened on success\n//       feedListener.spyClear();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" }\n//         })\n//       );\n\n//       await promisify(process.nextTick)(); // eslint-disable-line no-await-in-loop\n\n//       expect(feedListener.opening.calls.count()).toBe(1);\n//       expect(feedListener.opening.calls.argsFor(0).length).toBe(0);\n//       expect(feedListener.open.calls.count()).toBe(0);\n//       expect(feedListener.close.calls.count()).toBe(0);\n//       expect(feedListener.action.calls.count()).toBe(0);\n\n//       // Successfully re-open the feed\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" },\n//           FeedData: {}\n//         })\n//       );\n//     }\n\n//     // Transmit a final bad action revelation; the session will ask to close the feed\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"ActionRevelation\",\n//         ActionName: \"SomeAction\",\n//         ActionData: {},\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedDeltas: [{ Path: [], Operation: \"Delete\" }]\n//       })\n//     );\n\n//     await promisify(process.nextTick)(); // Move past queued events\n\n//     // Check that the feed is NOT re-opened on success\n//     feedListener.spyClear();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedCloseResponse\",\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" }\n//       })\n//     );\n\n//     await promisify(process.nextTick)();\n\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n\n//     // Advance reopenTrailingMs and ensure the feed is reopened\n//     feedListener.spyClear();\n//     jasmine.clock().tick(opts.reopenTrailingMs);\n\n//     await promisify(process.nextTick)();\n\n//     expect(feedListener.opening.calls.count()).toBe(1);\n//     expect(feedListener.opening.calls.argsFor(0).length).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n//   });\n\n//   it(\"if reopenMaxAttempts is positive and reopenTrailingMs is zero, should respect that limit over the duration of the connection\", async () => {\n//     const opts = {\n//       reopenMaxAttempts: 5,\n//       reopenTrailingMs: 0\n//     };\n//     const harness = harnessFactory(opts);\n//     await harness.connectClient();\n\n//     // Open the feed\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Args\" });\n//     feed.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: true,\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedData: {}\n//       })\n//     );\n\n//     await promisify(process.nextTick)(); // Move past queued events\n\n//     // Have the feed fail reopenMaxAttempts times\n//     const feedListener = harness.createFeedListener(feed);\n//     for (let i = 0; i < opts.reopenMaxAttempts; i += 1) {\n//       // Transmit a bad action revelation; the session will ask to close the feed\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionRevelation\",\n//           ActionName: \"SomeAction\",\n//           ActionData: {},\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" },\n//           FeedDeltas: [{ Path: [], Operation: \"Delete\" }]\n//         })\n//       );\n\n//       // Move past queued events\n//       await promisify(process.nextTick)(); // eslint-disable-line no-await-in-loop\n\n//       // Check that the feed is re-opened on success\n//       feedListener.spyClear();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" }\n//         })\n//       );\n\n//       await promisify(process.nextTick)(); // eslint-disable-line no-await-in-loop\n\n//       expect(feedListener.opening.calls.count()).toBe(1);\n//       expect(feedListener.opening.calls.argsFor(0).length).toBe(0);\n//       expect(feedListener.open.calls.count()).toBe(0);\n//       expect(feedListener.close.calls.count()).toBe(0);\n//       expect(feedListener.action.calls.count()).toBe(0);\n\n//       // Successfully re-open the feed\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Args\" },\n//           FeedData: {}\n//         })\n//       );\n//     }\n\n//     // Transmit a final bad action revelation; the session will ask to close the feed\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"ActionRevelation\",\n//         ActionName: \"SomeAction\",\n//         ActionData: {},\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" },\n//         FeedDeltas: [{ Path: [], Operation: \"Delete\" }]\n//       })\n//     );\n\n//     await promisify(process.nextTick)(); // Move past queued events\n\n//     // Check that the feed is NOT re-opened on success\n//     feedListener.spyClear();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedCloseResponse\",\n//         FeedName: \"SomeFeed\",\n//         FeedArgs: { Feed: \"Args\" }\n//       })\n//     );\n\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n\n//     // Run all timers and make sure the feed is not reopened\n//     feedListener.spyClear();\n//     jasmine.clock().tick(Math.MAX_SAFE_INTEGER);\n\n//     expect(feedListener.opening.calls.count()).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n\n//     // Disconnect and reconnect and make sure the feed is reopened\n//     harness.client.disconnect();\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\");\n\n//     await promisify(process.nextTick)(); // Move past queued events\n\n//     feedListener.spyClear();\n//     await harness.connectClient();\n\n//     expect(feedListener.opening.calls.count()).toBe(1);\n//     expect(feedListener.opening.calls.argsFor(0).length).toBe(0);\n//     expect(feedListener.open.calls.count()).toBe(0);\n//     expect(feedListener.close.calls.count()).toBe(0);\n//     expect(feedListener.action.calls.count()).toBe(0);\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// /*\n\n// App-initiated operations.\n\n// Includes all client and feed functions except for basic state-retrieving\n// functions (listed below). Tested only under the default configuration.\n\n// Each app-initiated operation has a group of tests that check all the way through\n// to conclusion, emulating any direct transport responses.\n\n// For each operation, check\n//   - Error and return values\n//   - Client and feed state function return values/errors\n//       client.state()\n//       client.id()\n//       feed.desiredState()\n//       feed.state()\n//       feed.data()\n//   - Client and feed events\n//   - Transport calls\n//   - Callbacks\n\n// */\n\n// describe(\"The client.connect() function\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   // Errors and return values\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw if connecting\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       expect(() => {\n//         harness.client.connect();\n//       }).toThrow(new Error(\"INVALID_STATE: Already connecting or connected.\"));\n//     });\n\n//     it(\"should throw if connected\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       expect(() => {\n//         harness.client.connect();\n//       }).toThrow(new Error(\"INVALID_STATE: Already connecting or connected.\"));\n//     });\n\n//     it(\"should return nothing on success\", () => {\n//       const harness = harnessFactory();\n//       expect(harness.client.connect()).toBeUndefined();\n//     });\n//   });\n\n//   // Client and feed state functions\n\n//   describe(\"client and feed state function effects\", () => {\n//     it(\"should work correctly through a successful connection cycle\", () => {\n//       // Create a disconnected client and feed objects\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"disconnected\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Call client.connect() and have the transport emit connecting\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"connecting\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Have the transport emit connect and emit a successful handshake response\n//       // so that the client becomes connected\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"HandshakeResponse\",\n//           Success: true,\n//           Version: \"0.1\",\n//           ClientId: \"SOME_CLIENT_ID\"\n//         })\n//       );\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"opening\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Have the transport return success to feed open request\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"open\");\n//       expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     describe(\"should work correctly through a failing connection cycle\", () => {\n//       let harness;\n//       let feedWantedOpen;\n//       let feedWantedClosed;\n//       beforeEach(() => {\n//         // Create a connecting client and two feeds\n//         harness = harnessFactory();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n//         feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         harness.client.connect();\n//         harness.transport.state.and.returnValue(\"connecting\");\n//         harness.transport.emit(\"connecting\");\n//       });\n\n//       it(\"if due to timeout, should update appropriately\", () => {\n//         // Trigger the timeout\n//         jasmine\n//           .clock()\n//           .tick(harness.client._options.connectTimeoutMs + epsilon);\n//         // The client will disconnect the transport\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\n//           \"disconnect\",\n//           harness.transport.disconnect.calls.argsFor(0)[0]\n//         );\n\n//         // Check all state functions\n//         expect(harness.client.state()).toBe(\"disconnected\");\n//         expect(() => {\n//           harness.client.id();\n//         }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       it(\"if due to app call to client.disconnect(), should update appropriately\", () => {\n//         // Have the client disconnect\n//         harness.client.disconnect();\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\"disconnect\"); // Requested\n\n//         // Check all state functions\n//         expect(harness.client.state()).toBe(\"disconnected\");\n//         expect(() => {\n//           harness.client.id();\n//         }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       it(\"if due to transport internal failure, should update appropriately\", () => {\n//         // Have the transport disconnect\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//         // Check all state functions\n//         expect(harness.client.state()).toBe(\"disconnected\");\n//         expect(() => {\n//           harness.client.id();\n//         }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       it(\"if due to handshake rejection, should update appropriately\", () => {\n//         // Have the transport connect and emit a handshake failure\n//         harness.transport.state.and.returnValue(\"connected\");\n//         harness.transport.emit(\"connect\");\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"HandshakeResponse\",\n//             Success: false\n//           })\n//         ); // The client will disconnect the transport\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\n//           \"disconnect\",\n//           harness.transport.disconnect.calls.argsFor(0)[0]\n//         );\n\n//         // Check all state functions\n//         expect(harness.client.state()).toBe(\"disconnected\");\n//         expect(() => {\n//           harness.client.id();\n//         }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n//     });\n//   });\n\n//   // Client and feed events\n\n//   describe(\"client and feed event effects\", () => {\n//     it(\"should work correctly through a successful connection cycle\", async () => {\n//       // Create a disconnected client and feed objects\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       await promisify(process.nextTick)(); // Move past queued events\n\n//       // Create listeners\n//       const clientListener = harness.createClientListener();\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       // Call client.connect() and have the transport emit connecting\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n\n//       await promisify(process.nextTick)();\n\n//       // Check all client and feed events\n//       expect(clientListener.connecting.calls.count()).toBe(1);\n//       expect(clientListener.connecting.calls.argsFor(0).length).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//       // Reset listeners\n//       clientListener.spyClear();\n//       feedWantedOpenListener.spyClear();\n//       feedWantedClosedListener.spyClear();\n\n//       // Have the transport emit connect and emit a successful handshake response\n//       // so that the client becomes connected\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"HandshakeResponse\",\n//           Success: true,\n//           Version: \"0.1\",\n//           ClientId: \"SOME_CLIENT_ID\"\n//         })\n//       );\n\n//       await promisify(process.nextTick)();\n\n//       // Check all client and feed events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(1);\n//       expect(clientListener.connect.calls.argsFor(0).length).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//       expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//       // Reset listeners\n//       clientListener.spyClear();\n//       feedWantedOpenListener.spyClear();\n//       feedWantedClosedListener.spyClear();\n\n//       // Have the transport return success to feed open request\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       await promisify(process.nextTick)();\n\n//       // Check all client and feed events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count(1)).toBe(1);\n//       expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//     });\n\n//     describe(\"should work correctly through a failing connection cycle\", () => {\n//       let harness;\n//       let feedWantedOpen;\n//       let feedWantedClosed;\n//       beforeEach(() => {\n//         // Create a connecting client and two feeds\n//         harness = harnessFactory();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n//         feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         harness.client.connect();\n//         harness.transport.state.and.returnValue(\"connecting\");\n//         harness.transport.emit(\"connecting\");\n//       });\n\n//       it(\"if due to timeout, should update appropriately\", () => {\n//         // Create listeners\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Trigger the timeout\n//         jasmine\n//           .clock()\n//           .tick(harness.client._options.connectTimeoutMs + epsilon);\n//         // The client will disconnect the transport\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\n//           \"disconnect\",\n//           harness.transport.disconnect.calls.argsFor(0)[0]\n//         );\n\n//         // Check all client and feed events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(clientListener.disconnect.calls.argsFor(0)[0].message).toBe(\n//           harness.transport.disconnect.calls.argsFor(0)[0].message\n//         );\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       it(\"if due to app call to client.disconnect(), should update appropriately\", () => {\n//         // Create listeners\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Have the client disconnect\n//         harness.client.disconnect();\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\"disconnect\"); // Requested\n\n//         // Check all client and feed events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       it(\"if due to transport internal failure, should update appropriately\", () => {\n//         // Create listeners\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Have the transport disconnect\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//         // Check all client and feed events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(clientListener.disconnect.calls.argsFor(0)[0].message).toBe(\n//           \"FAILURE: ...\"\n//         );\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       it(\"if due to handshake rejection, should update appropriately\", () => {\n//         // Create listeners\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Have the transport connect and emit a handshake failure\n//         harness.transport.state.and.returnValue(\"connected\");\n//         harness.transport.emit(\"connect\");\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"HandshakeResponse\",\n//             Success: false\n//           })\n//         ); // The client will disconnect the transport\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\n//           \"disconnect\",\n//           harness.transport.disconnect.calls.argsFor(0)[0]\n//         );\n\n//         // Check all client and feed events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(1);\n//         expect(clientListener.disconnect.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(clientListener.disconnect.calls.argsFor(0)[0].message).toBe(\n//           \"HANDSHAKE_REJECTED: The server rejected the handshake.\"\n//         );\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n//     });\n//   });\n\n//   // Transport calls\n\n//   describe(\"transport calls\", () => {\n//     describe(\"should work correctly through a successful connection cycle\", () => {\n//       it(\"if a feed is desired open, make appropriate transport calls\", () => {\n//         // Create a disconnected client and feed objects\n//         const harness = harnessFactory();\n//         const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n//         harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n\n//         // Call client.connect()\n//         harness.client.connect();\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(1);\n//         expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport emit connecting\n//         harness.transport.state.and.returnValue(\"connecting\");\n//         harness.transport.emit(\"connecting\");\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport emit connect\n//         harness.transport.state.and.returnValue(\"connected\");\n//         harness.transport.emit(\"connect\");\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//           JSON.stringify({\n//             MessageType: \"Handshake\",\n//             Versions: [\"0.1\"]\n//           })\n//         );\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a successful handshake response\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"HandshakeResponse\",\n//             Success: true,\n//             Version: \"0.1\",\n//             ClientId: \"SOME_CLIENT_ID\"\n//           })\n//         );\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//           JSON.stringify({\n//             MessageType: \"FeedOpen\",\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" }\n//           })\n//         );\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // // Have the transport return success to feed open request\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       it(\"if no feeds are desired open, make appropriate transport calls\", () => {\n//         // Create a disconnected client and feed objects\n//         const harness = harnessFactory();\n//         harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n\n//         // Call client.connect()\n//         harness.client.connect();\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(1);\n//         expect(harness.transport.connect.calls.argsFor(0).length).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport emit connecting\n//         harness.transport.state.and.returnValue(\"connecting\");\n//         harness.transport.emit(\"connecting\");\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport emit connect\n//         harness.transport.state.and.returnValue(\"connected\");\n//         harness.transport.emit(\"connect\");\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//           JSON.stringify({\n//             MessageType: \"Handshake\",\n//             Versions: [\"0.1\"]\n//           })\n//         );\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a successful handshake response\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"HandshakeResponse\",\n//             Success: true,\n//             Version: \"0.1\",\n//             ClientId: \"SOME_CLIENT_ID\"\n//           })\n//         );\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n//     });\n\n//     describe(\"should work correctly through a failing connection cycle\", () => {\n//       let harness;\n//       let feedWantedOpen;\n//       beforeEach(() => {\n//         // Create a connecting client and two feeds\n//         harness = harnessFactory();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n//         harness.client.connect();\n//         harness.transport.state.and.returnValue(\"connecting\");\n//         harness.transport.emit(\"connecting\");\n//       });\n\n//       it(\"if due to timeout, should be appropriate\", () => {\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Trigger the timeout\n//         jasmine\n//           .clock()\n//           .tick(harness.client._options.connectTimeoutMs + epsilon);\n//         // The client will disconnect the transport\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\n//           \"disconnect\",\n//           harness.transport.disconnect.calls.argsFor(0)[0]\n//         );\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(1);\n//         expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(1);\n//         expect(harness.transport.disconnect.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(harness.transport.disconnect.calls.argsFor(0)[0].message).toBe(\n//           \"TIMEOUT: The connection attempt timed out.\"\n//         );\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Connection retries are tested alongside configuration\n//       });\n\n//       it(\"if due to app call to client.disconnect(), should be appropriate\", () => {\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the client disconnect\n//         harness.client.disconnect();\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\"disconnect\"); // Requested\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(1);\n//         expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(0); // Requested\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Connection retries are tested alongside configuration\n//       });\n\n//       it(\"if due to transport internal failure, should be appropriate\", () => {\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport disconnect\n//         harness.transport.state.and.returnValue(\"disconnected\");\n//         harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Connection retries are tested alongside configuration\n//       });\n\n//       it(\"if due to handshake rejection, should be appropriate\", () => {\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport connect so the client submits a handshake\n//         harness.transport.state.and.returnValue(\"connected\");\n//         harness.transport.emit(\"connect\");\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//         expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//           JSON.stringify({\n//             MessageType: \"Handshake\",\n//             Versions: [\"0.1\"]\n//           })\n//         );\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Have the transport handshake failure\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"HandshakeResponse\",\n//             Success: false\n//           })\n//         ); // The client will call transport.disconnect()\n\n//         // Check all transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(1);\n//         expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(1);\n//         expect(harness.transport.disconnect.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(harness.transport.disconnect.calls.argsFor(0)[0].message).toBe(\n//           \"HANDSHAKE_REJECTED: The server rejected the handshake.\"\n//         );\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//         // Absence of connection retry are tested alongside configuration\n//       });\n//     });\n//   });\n\n//   // Callbacks - N/A\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The client.disconnect() function\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   // Errors and return values\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw if disconnected\", () => {\n//       const harness = harnessFactory();\n//       expect(() => {\n//         harness.client.disconnect();\n//       }).toThrow(new Error(\"INVALID_STATE: Already disconnected.\"));\n//     });\n\n//     it(\"should return void if not disconnected\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       expect(harness.client.disconnect()).toBeUndefined();\n//     });\n//   });\n\n//   // Client and feed state functions\n\n//   describe(\"client and feed state function effects\", () => {\n//     it(\"should work correctly if called while transport connecting\", () => {\n//       // Create a disconnected client and two feeds\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       // Put the client in a connecting state\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"connecting\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"disconnected\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     it(\"should work correctly if called while awaiting handshake response\", () => {\n//       // Create a disconnected client and two feeds\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       // Get the client so it is awaiting a handshake response\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\"); // Transport will send Handshake message\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"connecting\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"disconnected\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     it(\"should work correctly if called while while client is connected\", async () => {\n//       // Create a connected client and two feeds\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       await harness.connectClient();\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"opening\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all state functions\n//       expect(harness.client.state()).toBe(\"disconnected\");\n//       expect(() => {\n//         harness.client.id();\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n//   });\n\n//   // Client and feed events\n\n//   describe(\"client and feed event effects\", () => {\n//     it(\"should work correctly if called while transport connecting\", () => {\n//       // Create a disconnected client and two feeds\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       // Put the client in a connecting state\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n\n//       // Create listeners\n//       const clientListener = harness.createClientListener();\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all client and feed events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(1);\n//       expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0); // Requested\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(0); // Feed was never opening (no handshake)\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//     });\n\n//     it(\"should work correctly if called while awaiting handshake response\", () => {\n//       // Create a disconnected client and two feeds\n//       const harness = harnessFactory();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       // Get the client so it is awaiting a handshake response\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\"); // Transport will send Handshake message\n\n//       // Create listeners\n//       const clientListener = harness.createClientListener();\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all client and feed events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(1);\n//       expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0); // Requested\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(0); // Feed was never opening (no handshake)\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//       // Reset listeners\n//       clientListener.spyClear();\n//       feedWantedOpenListener.spyClear();\n//       feedWantedClosedListener.spyClear();\n//     });\n\n//     it(\"should work correctly if called while while client is connected\", async () => {\n//       // Create a connected client and two feeds\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       await promisify(process.nextTick)(); // Move past queued events\n\n//       // Create listeners\n//       const clientListener = harness.createClientListener();\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       await promisify(process.nextTick)();\n\n//       // Check all client and feed events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(1);\n//       expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0); // Requested\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(1); // Feed was opening\n//       expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//       expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//         \"DISCONNECTED: The transport disconnected.\"\n//       );\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//       // Reset listeners\n//       clientListener.spyClear();\n//       feedWantedOpenListener.spyClear();\n//       feedWantedClosedListener.spyClear();\n//     });\n//   });\n\n//   // Transport calls\n\n//   describe(\"transport calls\", () => {\n//     it(\"should work correctly if called while transport connecting\", () => {\n//       // Create a disconnected client and two feeds\n//       const harness = harnessFactory();\n\n//       // Put the client in a connecting state\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n\n//       // Reset transport spies\n//       harness.transport.spyClear();\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all transport calls\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(1);\n//       expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n\n//     it(\"should work correctly if called while awaiting handshake response\", () => {\n//       // Create a disconnected client and two feeds\n//       const harness = harnessFactory();\n\n//       // Get the client so it is awaiting a handshake response\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\"); // Transport will send Handshake message\n\n//       // Reset transport spies\n//       harness.transport.spyClear();\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all transport calls\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(1);\n//       expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n\n//     it(\"should work correctly if called while while client is connected\", async () => {\n//       // Create a connected client and two feeds\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset transport spies\n//       harness.transport.spyClear();\n\n//       // Call disconnect and have the transport emit disconnect\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check all transport calls\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(1);\n//       expect(harness.transport.disconnect.calls.argsFor(0).length).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n//   });\n\n//   // Callbacks - N/A\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The client.action() function\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   // Errors and return values\n\n//   describe(\"throw and return - callback style\", () => {\n//     it(\"should throw on bad argument (just test one)\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       expect(() => {\n//         harness.client.action(\"some_action\", { action: \"args\" }, \"junk\");\n//       }).toThrow(new Error(\"INVALID_ARGUMENT: Invalid callback.\"));\n//     });\n\n//     it(\"should throw if not connected\", () => {\n//       const harness = harnessFactory();\n//       expect(() => {\n//         harness.client.action(\"SomeAction\", {}, () => {});\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//     });\n\n//     it(\"should return void on success\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       expect(harness.client.action(\"SomeAction\", {}, () => {})).toBeUndefined();\n//     });\n//   });\n\n//   describe(\"throw and return - promise style\", () => {\n//     it(\"should throw on bad argument (just test one)\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       expect(() => {\n//         harness.client.action(\"some_action\", 123);\n//       }).toThrow(\n//         new Error(\"INVALID_ARGUMENT: Invalid action arguments object.\")\n//       );\n//     });\n\n//     it(\"should throw if not connected\", () => {\n//       const harness = harnessFactory();\n//       expect(() => {\n//         harness.client.action(\"SomeAction\", {});\n//       }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//     });\n\n//     it(\"should return promise on success\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       expect(harness.client.action(\"SomeAction\", {})).toEqual(\n//         jasmine.any(Promise)\n//       );\n//     });\n//   });\n\n//   // Client and feed state functions - N/A\n\n//   // Client and feed events - N/A\n\n//   // Transport calls\n\n//   describe(\"transport calls - callback style\", () => {\n//     it(\"should send an Action message on the transport\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset transport spies\n//       harness.transport.spyClear();\n\n//       // Invoke an action\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, () => {});\n\n//       // Check all transport calls\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(1);\n//       expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//       // You can't check the whole message in one go, since callback id is created internally\n//       const msg = JSON.parse(harness.transport.send.calls.argsFor(0)[0]);\n//       expect(msg.MessageType).toBe(\"Action\");\n//       expect(msg.ActionName).toBe(\"SomeAction\");\n//       expect(msg.ActionArgs).toEqual({ Action: \"Arg\" });\n//       expect(\n//         typeof msg.CallbackId === \"string\" || msg.CallbackId instanceof String\n//       ).toBe(true);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n//   });\n\n//   // describe(\"transport calls - promise style\", function() {\n//   //   it(\"should send an Action message on the transport\", function() {\n//   //     var harness = harnessFactory();\n//   //     await harness.connectClient();\n\n//   //     // Reset transport spies\n//   //     harness.transport.spyClear();\n\n//   //     // Invoke an action\n//   //     harness.client.action(\"SomeAction\", { Action: \"Arg\" });\n\n//   //     // Check all transport calls\n//   //     expect(harness.transport.connect.calls.count()).toBe(0);\n//   //     expect(harness.transport.disconnect.calls.count()).toBe(0);\n//   //     expect(harness.transport.send.calls.count()).toBe(1);\n//   //     expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//   //     // You can't check the whole message in one go, since callback id is created internally\n//   //     var msg = JSON.parse(harness.transport.send.calls.argsFor(0)[0]);\n//   //     expect(msg.MessageType).toBe(\"Action\");\n//   //     expect(msg.ActionName).toBe(\"SomeAction\");\n//   //     expect(msg.ActionArgs).toEqual({ Action: \"Arg\" });\n//   //     expect(\n//   //       typeof msg.CallbackId === \"string\" || msg.CallbackId instanceof String\n//   //     ).toBe(true);\n//   //     expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//   //   });\n//   // });\n\n//   // Callbacks\n\n//   describe(\"callbacks - callback style\", () => {\n//     it(\"should operate correctly through a timeout cycle to final success\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset the transport so you can get the callback\n//       harness.transport.spyClear();\n\n//       // Create callbacks and invoke an action\n//       const cb = jasmine.createSpy();\n//       const cbLate = jasmine.createSpy();\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb, cbLate);\n\n//       // Get the CallbackId sent with the Action message\n//       const serverCb = JSON.parse(harness.transport.send.calls.argsFor(0)[0])\n//         .CallbackId;\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Run the timeout\n//       jasmine.clock().tick(harness.client._options.actionTimeoutMs);\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(1);\n//       expect(cb.calls.argsFor(0).length).toBe(1);\n//       expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cb.calls.argsFor(0)[0].message).toBe(\n//         \"TIMEOUT: The server did not respond within the allocated time.\"\n//       );\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Reset the callbacks\n//       cb.calls.reset();\n//       cbLate.calls.reset();\n\n//       // Have the server return success\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionResponse\",\n//           CallbackId: serverCb,\n//           Success: true,\n//           ActionData: { Action: \"Data\" }\n//         })\n//       );\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(1);\n//       expect(cbLate.calls.argsFor(0).length).toBe(2);\n//       expect(cbLate.calls.argsFor(0)[0]).toBeUndefined();\n//       expect(cbLate.calls.argsFor(0)[1]).toEqual({ Action: \"Data\" });\n//     });\n\n//     it(\"should operate correctly through a timeout cycle to final disconnect\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset the transport so you can get the callback\n//       harness.transport.spyClear();\n\n//       // Create callbacks and invoke an action\n//       const cb = jasmine.createSpy();\n//       const cbLate = jasmine.createSpy();\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb, cbLate);\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Run the timeout\n//       jasmine.clock().tick(harness.client._options.actionTimeoutMs);\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(1);\n//       expect(cb.calls.argsFor(0).length).toBe(1);\n//       expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cb.calls.argsFor(0)[0].message).toBe(\n//         \"TIMEOUT: The server did not respond within the allocated time.\"\n//       );\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Reset the callbacks\n//       cb.calls.reset();\n//       cbLate.calls.reset();\n\n//       // Have the client disconnect (requested in this case)\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(1);\n//       expect(cbLate.calls.argsFor(0).length).toBe(1);\n//       expect(cbLate.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cbLate.calls.argsFor(0)[0].message).toBe(\n//         \"DISCONNECTED: The transport disconnected.\"\n//       );\n//     });\n\n//     it(\"should operate correctly through a timeout cycle to final reject\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset the transport so you can get the callback\n//       harness.transport.spyClear();\n\n//       // Create callbacks and invoke an action\n//       const cb = jasmine.createSpy();\n//       const cbLate = jasmine.createSpy();\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb, cbLate);\n\n//       // Get the CallbackId sent with the Action message\n//       const serverCb = JSON.parse(harness.transport.send.calls.argsFor(0)[0])\n//         .CallbackId;\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Run the timeout\n//       jasmine.clock().tick(harness.client._options.actionTimeoutMs);\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(1);\n//       expect(cb.calls.argsFor(0).length).toBe(1);\n//       expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cb.calls.argsFor(0)[0].message).toBe(\n//         \"TIMEOUT: The server did not respond within the allocated time.\"\n//       );\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Reset the callbacks\n//       cb.calls.reset();\n//       cbLate.calls.reset();\n\n//       // Have the server reject the action\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionResponse\",\n//           CallbackId: serverCb,\n//           Success: false,\n//           ErrorCode: \"SERVER_ERROR_CODE\",\n//           ErrorData: { Server: \"Data\" }\n//         })\n//       );\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(1);\n//       expect(cbLate.calls.argsFor(0).length).toBe(1);\n//       expect(cbLate.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cbLate.calls.argsFor(0)[0].message).toBe(\n//         \"REJECTED: Server rejected the action request.\"\n//       );\n//       expect(cbLate.calls.argsFor(0)[0].serverErrorCode).toBe(\n//         \"SERVER_ERROR_CODE\"\n//       );\n//       expect(cbLate.calls.argsFor(0)[0].serverErrorData).toEqual({\n//         Server: \"Data\"\n//       });\n//     });\n\n//     it(\"should operate correctly on success\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset the transport so you can get the callback\n//       harness.transport.spyClear();\n\n//       // Create callbacks and invoke an action\n//       const cb = jasmine.createSpy();\n//       const cbLate = jasmine.createSpy();\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb, cbLate);\n\n//       // Get the CallbackId sent with the Action message\n//       const serverCb = JSON.parse(harness.transport.send.calls.argsFor(0)[0])\n//         .CallbackId;\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Have the server return success\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionResponse\",\n//           CallbackId: serverCb,\n//           Success: true,\n//           ActionData: { Action: \"Data\" }\n//         })\n//       );\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(1);\n//       expect(cb.calls.argsFor(0).length).toBe(2);\n//       expect(cb.calls.argsFor(0)[0]).toBeUndefined();\n//       expect(cb.calls.argsFor(0)[1]).toEqual({ Action: \"Data\" });\n//       expect(cbLate.calls.count()).toBe(0);\n//     });\n\n//     it(\"should operate correctly on disconnect\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset the transport so you can get the callback\n//       harness.transport.spyClear();\n\n//       // Create callbacks and invoke an action\n//       const cb = jasmine.createSpy();\n//       const cbLate = jasmine.createSpy();\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb, cbLate);\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Have the client disconnect (requested in this case)\n//       harness.client.disconnect();\n//       harness.transport.state.and.returnValue(\"disconnected\");\n//       harness.transport.emit(\"disconnect\");\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(1);\n//       expect(cb.calls.argsFor(0).length).toBe(1);\n//       expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cb.calls.argsFor(0)[0].message).toBe(\n//         \"DISCONNECTED: The transport disconnected.\"\n//       );\n//       expect(cbLate.calls.count()).toBe(0);\n//     });\n\n//     it(\"should operate correctly on reject\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n\n//       // Reset the transport so you can get the callback\n//       harness.transport.spyClear();\n\n//       // Create callbacks and invoke an action\n//       const cb = jasmine.createSpy();\n//       const cbLate = jasmine.createSpy();\n//       harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb, cbLate);\n\n//       // Get the CallbackId sent with the Action message\n//       const serverCb = JSON.parse(harness.transport.send.calls.argsFor(0)[0])\n//         .CallbackId;\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(0);\n//       expect(cbLate.calls.count()).toBe(0);\n\n//       // Have the server reject the action\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionResponse\",\n//           CallbackId: serverCb,\n//           Success: false,\n//           ErrorCode: \"SERVER_ERROR_CODE\",\n//           ErrorData: { Server: \"Data\" }\n//         })\n//       );\n\n//       // Check callbacks\n//       expect(cb.calls.count()).toBe(1);\n//       expect(cb.calls.argsFor(0).length).toBe(1);\n//       expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//       expect(cb.calls.argsFor(0)[0].message).toBe(\n//         \"REJECTED: Server rejected the action request.\"\n//       );\n//       expect(cb.calls.argsFor(0)[0].serverErrorCode).toBe(\"SERVER_ERROR_CODE\");\n//       expect(cb.calls.argsFor(0)[0].serverErrorData).toEqual({\n//         Server: \"Data\"\n//       });\n//       expect(cbLate.calls.count()).toBe(0);\n//     });\n//   });\n\n//   describe(\"callbacks - promise style\", () => {\n//     it(\"should operate correctly on action success\", done => {\n//       const harness = harnessFactory();\n//       harness\n//         .connectClient()\n//         .then(() => {\n//           // Reset the transport so you can get the callback\n//           harness.transport.spyClear();\n//         })\n//         .then(() => {\n//           harness.client\n//             .action(\"SomeAction\", { Action: \"Arg\" })\n//             .then(actionData => {\n//               expect(actionData).toEqual({ Action: \"Data\" });\n//               done();\n//             });\n//         })\n//         .then(() => {\n//           // Get the CallbackId sent with the Action message and return success\n//           // This settles the action promise above\n//           const serverCb = JSON.parse(\n//             harness.transport.send.calls.argsFor(0)[0]\n//           ).CallbackId;\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"ActionResponse\",\n//               CallbackId: serverCb,\n//               Success: true,\n//               ActionData: { Action: \"Data\" }\n//             })\n//           );\n//         });\n//     });\n\n//     it(\"should operate correctly on action rejection\", done => {\n//       const harness = harnessFactory();\n\n//       harness\n//         .connectClient()\n//         .then(() => {\n//           // Reset the transport so you can get the callback\n//           harness.transport.spyClear();\n//         })\n//         .then(() => {\n//           harness.client.action(\"SomeAction\", { Action: \"Arg\" }).catch(err => {\n//             expect(err).toEqual(jasmine.any(Error));\n//             expect(err.message).toEqual(\n//               \"REJECTED: Server rejected the action request.\"\n//             );\n//             expect(err.serverErrorCode).toBe(\"SOME_ERROR\");\n//             expect(err.serverErrorData).toEqual({ Error: \"Data\" });\n//             done();\n//           });\n//         })\n//         .then(() => {\n//           // Get the CallbackId sent with the Action message and return success\n//           // This settles the action promise above\n//           const serverCb = JSON.parse(\n//             harness.transport.send.calls.argsFor(0)[0]\n//           ).CallbackId;\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"ActionResponse\",\n//               CallbackId: serverCb,\n//               Success: false,\n//               ErrorCode: \"SOME_ERROR\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n//         });\n//     });\n\n//     it(\"should operate correctly on timeout\", done => {\n//       const harness = harnessFactory();\n\n//       harness\n//         .connectClient()\n//         .then(() => {\n//           // Reset the transport so you can get the callback\n//           harness.transport.spyClear();\n//         })\n//         .then(() => {\n//           harness.client.action(\"SomeAction\", { Action: \"Arg\" }).catch(err => {\n//             expect(err).toEqual(jasmine.any(Error));\n//             expect(err.message).toBe(\n//               \"TIMEOUT: The server did not respond within the allocated time.\"\n//             );\n//             done();\n//           });\n//         })\n//         .then(() => {\n//           // Run the timeout\n//           // This settles the action promise above\n//           jasmine.clock().tick(harness.client._options.actionTimeoutMs);\n//         });\n//     });\n\n//     it(\"should operate correctly on disconnect\", done => {\n//       const harness = harnessFactory();\n\n//       harness\n//         .connectClient()\n//         .then(() => {\n//           // Reset the transport so you can get the callback\n//           harness.transport.spyClear();\n//         })\n//         .then(() => {\n//           harness.client.action(\"SomeAction\", { Action: \"Arg\" }).catch(err => {\n//             expect(err).toEqual(jasmine.any(Error));\n//             expect(err.message).toBe(\n//               \"DISCONNECTED: The transport disconnected.\"\n//             );\n//             done();\n//           });\n//         })\n//         .then(() => {\n//           // Have the client disconnect (requested in this case)\n//           // This settles the action promise above\n//           harness.client.disconnect();\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\");\n//         });\n//     });\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The client.feed() function\", () => {\n//   // Errors and return values\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw on bad argument (check one)\", () => {\n//       const harness = harnessFactory();\n//       expect(() => {\n//         harness.client.feed(); // No args\n//       }).toThrow(new Error(\"INVALID_ARGUMENT: Invalid feed name.\"));\n//     });\n\n//     it(\"should return an object on success\", () => {\n//       const harness = harnessFactory();\n//       expect(harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" })).toEqual(\n//         jasmine.any(Object)\n//       );\n//     });\n//   });\n\n//   // Client and feed state functions - N/A\n\n//   // Client and feed events - N/A\n\n//   // Transport calls - N/A\n\n//   // Callbacks - N/A\n// });\n\n// /*\n\n// The feed.desireOpen() and feed.desireClosed() functions are tested using\n// a somewhat different approach than other functions. Instead of branching\n// into state functions, events, and transport calls at the root, the root\n// is used to branch into the various possible cases of (1) whether any other\n// feeds are desired open, and (2) the current state of the server feed. State\n// functions, events, and transport calls are then tested internally for each.\n\n// */\n\n// describe(\"The feed.desireOpen() function\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw if already desired open\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       expect(() => {\n//         feed.desireOpen();\n//       }).toThrow(\n//         new Error(\"INVALID_FEED_STATE: The feed is already desired open.\")\n//       );\n//     });\n\n//     it(\"should throw if destroyed\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.destroy();\n//       expect(() => {\n//         feed.desireOpen();\n//       }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//     });\n\n//     it(\"should return void on success\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       expect(feed.desireOpen()).toBeUndefined();\n//     });\n//   });\n\n//   describe(\"if disconnected\", () => {\n//     let harness;\n//     beforeEach(() => {\n//       harness = harnessFactory();\n//     });\n\n//     it(\"state functions\", () => {\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       // Check state functions\n//       expect(feed.desiredState()).toBe(\"closed\");\n//       expect(feed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Desire open\n//       feed.desireOpen();\n\n//       // Check state functions\n//       expect(feed.desiredState()).toBe(\"open\");\n//       expect(feed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     it(\"events\", async () => {\n//       const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       const feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       feedWantedOpen.desireOpen();\n\n//       await promisify(process.nextTick)();\n\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//       expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//       expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//         \"DISCONNECTED: The client is not connected.\"\n//       );\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//     });\n\n//     it(\"transport calls\", () => {\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//       harness.transport.spyClear();\n\n//       feed.desireOpen();\n\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n//   });\n\n//   describe(\"if connected and no other feed objects are desired open\", () => {\n//     describe(\"if the server feed is closed\", () => {\n//       let harness;\n//       beforeEach(async () => {\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//       });\n\n//       describe(\"if the server responds to FeedOpen with success\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"open\");\n//           expect(feed.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the client disconnects before the server responds to FeedOpen\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Tries to reconnect by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is opening\", () => {\n//       let harness;\n//       beforeEach(async () => {\n//         harness = harnessFactory();\n//         await harness.connectClient();\n\n//         // Get the server feed into the opening state\n//         const earlierFeed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         earlierFeed.desireOpen();\n//       });\n\n//       describe(\"if the server responds to earlier FeedOpen with success\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"open\");\n//           expect(feed.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to earlier FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the client disconnects before the server responds to earlier FeedOpen\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Tries to reconnect by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is open\", () => {\n//       // Can't happen - server feed would be closing if no other feeds objects desired open\n//     });\n\n//     describe(\"if the server feed is closing\", () => {\n//       let harness;\n//       beforeEach(async () => {\n//         // Get the server feed into the closing state\n//         harness = harnessFactory();\n//         await harness.connectClient();\n\n//         const earlierFeed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         earlierFeed.desireOpen();\n\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n\n//         earlierFeed.desireClosed();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the server responds to earlier FeedClose with success and subsequent FeedOpen with success\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"open\");\n//           expect(feed.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to earlier FeedClose with success and subsequent FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if client disconnects before the server responds to the ealier FeedClose\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//           feed.desireOpen();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the transport disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Tries to reconnect by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n//   });\n\n//   describe(\"if connected and another feed object is desired open\", () => {\n//     describe(\"if the server feed is closed\", () => {\n//       let harness;\n//       let feedAlreadyWantedOpen;\n//       beforeEach(async () => {\n//         // Set up a connected client with a feed desired open but actually closed\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedAlreadyWantedOpen = harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n//         feedAlreadyWantedOpen.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: false,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             ErrorCode: \"SOME_ERROR_CODE\",\n//             ErrorData: { Error: \"Data\" }\n//           })\n//         );\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the server responds to FeedOpen with success\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.opening.calls.argsFor(0).length\n//           ).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.open.calls.argsFor(0).length\n//           ).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return failure to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.opening.calls.argsFor(0).length\n//           ).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return failure to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0).length\n//           ).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0]\n//           ).toEqual(jasmine.any(Error));\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0].message\n//           ).toBe(\"REJECTED: Server rejected the feed open request.\");\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return failure to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the client disconnects before the server responds to FeedOpen\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the client disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.opening.calls.argsFor(0).length\n//           ).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the client disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0).length\n//           ).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0]\n//           ).toEqual(jasmine.any(Error));\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0].message\n//           ).toBe(\"DISCONNECTED: The transport disconnected.\");\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the client disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is opening\", () => {\n//       let harness;\n//       let feedAlreadyWantedOpen;\n//       beforeEach(async () => {\n//         // Set up a connected client with a feed desired open and server feed opening\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedAlreadyWantedOpen = harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n//         feedAlreadyWantedOpen.desireOpen();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the server responds to earlier FeedOpen with success\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire the feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.open.calls.argsFor(0).length\n//           ).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(0);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to earlier FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0).length\n//           ).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0]\n//           ).toEqual(jasmine.any(Error));\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0].message\n//           ).toBe(\"REJECTED: Server rejected the feed open request.\");\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the client disconnects before the server responds to earlier FeedOpen\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0).length\n//           ).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0]\n//           ).toEqual(jasmine.any(Error));\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0].message\n//           ).toBe(\"DISCONNECTED: The transport disconnected.\");\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Tries to reconnect by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is open\", () => {\n//       let harness;\n//       let feedAlreadyWantedOpen;\n//       beforeEach(async () => {\n//         // Set up a connected client with a feed desired open and server feed open\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedAlreadyWantedOpen = harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n//         feedAlreadyWantedOpen.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       it(\"state functions\", () => {\n//         // Desire feed open\n//         const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n\n//         // Check state functions\n//         expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedAlreadyWantedOpen.state()).toBe(\"open\");\n//         expect(feedAlreadyWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"open\");\n//         expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//       });\n\n//       it(\"events\", async () => {\n//         // Create feed listeners\n//         const feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n//         const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//           feedAlreadyWantedOpen\n//         );\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Desire the feed open\n//         feedWantedOpen.desireOpen();\n\n//         await promisify(process.nextTick)();\n\n//         // Check events\n//         expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//         expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//         expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       it(\"transport calls\", () => {\n//         const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Desire feed open\n//         feed.desireOpen();\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.argsFor(0).length).toBe(0);\n//       });\n//     });\n\n//     describe(\"if the server feed is closing\", () => {\n//       let harness;\n//       let feedAlreadyWantedOpen;\n//       beforeEach(async () => {\n//         // Get the server feed into the closing state with a feed desired open\n//         harness = harnessFactory();\n//         await harness.connectClient();\n\n//         feedAlreadyWantedOpen = harness.client.feed(\"SomeFeed\", {\n//           Feed: \"Arg\"\n//         });\n//         feedAlreadyWantedOpen.desireOpen();\n\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n\n//         feedAlreadyWantedOpen.desireClosed();\n//         feedAlreadyWantedOpen.desireOpen();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the server responds to earlier FeedClose with success and subsequent FeedOpen with success\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.open.calls.argsFor(0).length\n//           ).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to earlier FeedClose with success and subsequent FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0).length\n//           ).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0]\n//           ).toEqual(jasmine.any(Error));\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0].message\n//           ).toBe(\"REJECTED: Server rejected the feed open request.\");\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to the FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if client disconnects before the server responds to the ealier FeedClose\", () => {\n//         it(\"state functions\", () => {\n//           // Desire feed open\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           feedWantedOpen.desireOpen();\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedAlreadyWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedAlreadyWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedAlreadyWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           // Create feed listeners\n//           const feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedWantedClosed = harness.client.feed(\"SomeFeed\", {\n//             Feed: \"Arg\"\n//           });\n//           const feedAlreadyWantedOpenListener = harness.createFeedListener(\n//             feedAlreadyWantedOpen\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n\n//           // Desire feed open\n//           feedWantedOpen.desireOpen();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.opening.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedAlreadyWantedOpenListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the transport disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedAlreadyWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedAlreadyWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0).length\n//           ).toBe(1);\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0]\n//           ).toEqual(jasmine.any(Error));\n//           expect(\n//             feedAlreadyWantedOpenListener.close.calls.argsFor(0)[0].message\n//           ).toBe(\"DISCONNECTED: The transport disconnected.\");\n//           expect(feedAlreadyWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed open\n//           feed.desireOpen();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to the earlier FeedClose\n//           // Client will send FeedOpen message\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Tries to reconnect by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The feed.desireClosed() function\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw if already desired closed\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       expect(() => {\n//         feed.desireClosed();\n//       }).toThrow(\n//         new Error(\"INVALID_FEED_STATE: The feed is already desired closed.\")\n//       );\n//     });\n\n//     it(\"should throw if destroyed\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.destroy();\n//       expect(() => {\n//         feed.desireClosed();\n//       }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//     });\n\n//     it(\"should return void on success\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       expect(feed.desireClosed()).toBeUndefined();\n//     });\n//   });\n\n//   describe(\"if disconnected\", () => {\n//     let harness;\n//     let feedWantedOpen;\n//     let feedWantedClosed;\n//     beforeEach(() => {\n//       harness = harnessFactory();\n//       feedWantedOpen = harness.client.feed(\"SomeFeed\", {\n//         Feed: \"Arg\"\n//       });\n//       feedWantedOpen.desireOpen();\n//       feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedClosed.desireOpen();\n//     });\n\n//     it(\"state functions\", () => {\n//       // Check state functions\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Desire closed\n//       feedWantedClosed.desireClosed();\n\n//       // Check state functions\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     it(\"events\", () => {\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       feedWantedClosed.desireClosed();\n\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//     });\n\n//     it(\"transport calls\", () => {\n//       harness.transport.spyClear();\n\n//       feedWantedClosed.desireClosed();\n\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n//   });\n\n//   describe(\"if connected and no other feed objects are desired open\", () => {\n//     describe(\"if the server feed is closed\", () => {\n//       let harness;\n//       let feed;\n//       beforeEach(async () => {\n//         // Set up a feed object desired open but with the server feed closed (rejected)\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feed.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: false,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             ErrorCode: \"SOME_ERROR_CODE\",\n//             ErrorData: { Error: \"Data\" }\n//           })\n//         );\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(feed.desiredState()).toBe(\"open\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Desire closed\n//         feed.desireClosed();\n\n//         // Check state functions\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       it(\"events\", async () => {\n//         const feedListener = harness.createFeedListener(feed);\n\n//         feed.desireClosed();\n\n//         await promisify(process.nextTick)();\n\n//         // Check events\n//         expect(feedListener.opening.calls.count()).toBe(0);\n//         expect(feedListener.open.calls.count()).toBe(0);\n//         expect(feedListener.close.calls.count()).toBe(1);\n//         expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//         expect(feedListener.action.calls.count()).toBe(0);\n//       });\n\n//       it(\"transport calls\", () => {\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Desire feed closed\n//         feed.desireClosed();\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n//     });\n\n//     describe(\"if the server feed is opening\", () => {\n//       let harness;\n//       let feed;\n//       beforeEach(async () => {\n//         // Set up an opening feed\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feed.desireOpen();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the client disconnects before FeedOpenResponse\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedOpen with failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the server respond to FeedOpen with failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedOpen with failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with success and then disconnects before FeedCloseResponse\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedClose\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with success and FeedClose with success\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedClose\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is open\", () => {\n//       let harness;\n//       let feed;\n//       beforeEach(async () => {\n//         // Set up an open feed\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feed.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the server disconnects before FeedCloseResponse\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"open\");\n//           expect(feed.data()).toEqual({ Feed: \"Data\" });\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedClose\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedClose with success\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"open\");\n//           expect(feed.data()).toEqual({ Feed: \"Data\" });\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedClose\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is closing\", () => {\n//       let harness;\n//       let feed;\n//       beforeEach(async () => {\n//         // Set up a closing feed desired open\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feed.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n//         feed.desireClosed();\n//         feed.desireOpen();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the server disconnects before FeedCloseResponse\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedClose with success\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"open\");\n//           expect(feed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feed.desiredState()).toBe(\"closed\");\n//           expect(feed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedListener = harness.createFeedListener(feed);\n\n//           feed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(1);\n//           expect(feedListener.close.calls.argsFor(0).length).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedListener.spyClear();\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedListener.opening.calls.count()).toBe(0);\n//           expect(feedListener.open.calls.count()).toBe(0);\n//           expect(feedListener.close.calls.count()).toBe(0);\n//           expect(feedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedClose with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n//   });\n\n//   describe(\"if connected and another feed object is desired open\", () => {\n//     describe(\"if the server feed is closed\", () => {\n//       let harness;\n//       let feedWantedClosed;\n//       let feedWantedOpen;\n//       beforeEach(async () => {\n//         // Set up a feed object desired open but with the server feed closed (rejected)\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n//         feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedClosed.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: false,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             ErrorCode: \"SOME_ERROR_CODE\",\n//             ErrorData: { Error: \"Data\" }\n//           })\n//         );\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Desire closed\n//         feedWantedClosed.desireClosed();\n\n//         // Check state functions\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       it(\"events\", async () => {\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n\n//         feedWantedClosed.desireClosed();\n\n//         await promisify(process.nextTick)();\n\n//         // Check events\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//         expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       });\n\n//       it(\"transport calls\", () => {\n//         // Reset transport spies\n//         harness.transport.spyClear();\n\n//         // Desire feed closed\n//         feedWantedClosed.desireClosed();\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n//     });\n\n//     describe(\"if the server feed is opening\", () => {\n//       let harness;\n//       let feedWantedClosed;\n//       let feedWantedOpen;\n//       beforeEach(async () => {\n//         // Set up an opening feed\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedClosed.desireOpen();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the client disconnects before FeedOpenResponse\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with failure\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedOpen with failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n\n//           // Have the server respond to FeedOpen with failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedOpen with failure\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the server responds to FeedOpen with success and then eventually disconnects\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server respond to FeedOpen with success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is open\", () => {\n//       let harness;\n//       let feedWantedClosed;\n//       let feedWantedOpen;\n//       beforeEach(async () => {\n//         // Set up an open feed\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedClosed.desireOpen();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"when the client eventually disconnects\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"open\");\n//           expect(feedWantedClosed.data()).toEqual({ Feed: \"Data\" });\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n\n//     describe(\"if the server feed is closing\", () => {\n//       let harness;\n//       let feedWantedClosed;\n//       let feedWantedOpen;\n//       beforeEach(async () => {\n//         // Set up a closing feed desired open by two objects\n//         harness = harnessFactory();\n//         await harness.connectClient();\n//         feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedClosed.desireOpen();\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"FeedOpenResponse\",\n//             Success: true,\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedData: { Feed: \"Data\" }\n//           })\n//         );\n//         feedWantedClosed.desireClosed();\n//         feedWantedClosed.desireOpen();\n//         feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//         feedWantedOpen.desireOpen();\n\n//         await promisify(process.nextTick)(); // Move past queued events\n//       });\n\n//       describe(\"if the client disconnects before receiving a response to earlier FeedClose\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the earlier FeedClose succeeds then client disconnects before FeedOpenResponse\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"DISCONNECTED: The transport disconnected.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the transport disconnect from the server\n//           harness.transport.state.and.returnValue(\"disconnected\");\n//           harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the earlier FeedClose succeeds and FeedOpen fails\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return failure to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the server return failure to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//             jasmine.any(Error)\n//           );\n//           expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//             \"REJECTED: Server rejected the feed open request.\"\n//           );\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return failure to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: false,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               ErrorCode: \"SOME_ERROR_CODE\",\n//               ErrorData: { Error: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n\n//       describe(\"if the earlier FeedClose succeeds and FeedOpen succeeds\", () => {\n//         it(\"state functions\", () => {\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"open\");\n//           expect(feedWantedClosed.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"opening\");\n//           expect(() => {\n//             feedWantedOpen.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n\n//           // Have the server return success to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check state functions\n//           expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//           expect(feedWantedClosed.state()).toBe(\"closed\");\n//           expect(() => {\n//             feedWantedClosed.data();\n//           }).toThrow(\n//             new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//           );\n//           expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//           expect(feedWantedOpen.state()).toBe(\"open\");\n//           expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         });\n\n//         it(\"events\", async () => {\n//           const feedWantedClosedListener = harness.createFeedListener(\n//             feedWantedClosed\n//           );\n//           const feedWantedOpenListener = harness.createFeedListener(\n//             feedWantedOpen\n//           );\n\n//           feedWantedClosed.desireClosed();\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(1);\n//           expect(feedWantedClosedListener.close.calls.argsFor(0).length).toBe(\n//             0\n//           );\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n\n//           // Reset listeners\n//           feedWantedClosedListener.spyClear();\n//           feedWantedOpenListener.spyClear();\n\n//           // Have the server return success to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           await promisify(process.nextTick)();\n\n//           // Check events\n//           expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//           expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.open.calls.count()).toBe(1);\n//           expect(feedWantedOpenListener.open.calls.argsFor(0).length).toBe(0);\n//           expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//           expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         });\n\n//         it(\"transport calls\", () => {\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Desire feed closed\n//           feedWantedClosed.desireClosed();\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return FeedCloseResponse success\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedCloseResponse\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count()).toBe(0);\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0).length).toBe(1);\n//           expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//             JSON.stringify({\n//               MessageType: \"FeedOpen\",\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" }\n//             })\n//           );\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n\n//           // Reset transport spies\n//           harness.transport.spyClear();\n\n//           // Have the server return success to FeedOpen\n//           harness.transport.emit(\n//             \"message\",\n//             JSON.stringify({\n//               MessageType: \"FeedOpenResponse\",\n//               Success: true,\n//               FeedName: \"SomeFeed\",\n//               FeedArgs: { Feed: \"Arg\" },\n//               FeedData: { Feed: \"Data\" }\n//             })\n//           );\n\n//           // Check transport calls\n//           expect(harness.transport.connect.calls.count() >= 0).toBe(true); // Reconnects by default\n//           expect(harness.transport.disconnect.calls.count()).toBe(0);\n//           expect(harness.transport.send.calls.count()).toBe(0);\n//           expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//         });\n//       });\n//     });\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"The feed.destroy() function\", () => {\n//   // Errors and return values\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw if desired open\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       expect(() => {\n//         feed.destroy();\n//       }).toThrow(\n//         new Error(\n//           \"INVALID_FEED_STATE: Only feeds desired closed can be destroyed.\"\n//         )\n//       );\n//     });\n\n//     it(\"should throw if already destroyed\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.destroy();\n//       expect(() => {\n//         feed.destroy();\n//       }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//     });\n\n//     it(\"should return void\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       expect(feed.destroy()).toBeUndefined();\n//     });\n//   });\n\n//   // Client and feed state functions - N/A\n\n//   // Client and feed events - N/A\n\n//   // Transport calls - N/A\n\n//   // Callbacks - N/A\n// });\n\n// describe(\"The feed.client() function\", () => {\n//   // Errors and return values\n\n//   describe(\"throw and return\", () => {\n//     it(\"should throw if already destroyed\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.destroy();\n//       expect(() => {\n//         feed.client();\n//       }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//     });\n\n//     it(\"should return the client\", () => {\n//       const harness = harnessFactory();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       expect(feed.client()).toBe(harness.client);\n//     });\n//   });\n\n//   // Client and feed state functions - N/A\n\n//   // Client and feed events - N/A\n\n//   // Transport calls - N/A\n\n//   // Callbacks - N/A\n// });\n\n// /*\n\n// State functions\n\n// Tested heavily above - just check a few error cases.\n\n// */\n\n// describe(\"The client.state() function\", () => {\n//   // No errors\n// });\n\n// describe(\"The client.id() function\", () => {\n//   // INVALID_STATE tested through the connection cycle above\n// });\n\n// describe(\"The feed.desiredState() function\", () => {\n//   it(\"should throw if destroyed\", () => {\n//     const harness = harnessFactory();\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//     feed.destroy();\n//     expect(() => {\n//       feed.desiredState();\n//     }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//   });\n// });\n\n// describe(\"The feed.state() function\", () => {\n//   it(\"should throw if destroyed\", () => {\n//     const harness = harnessFactory();\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//     feed.destroy();\n//     expect(() => {\n//       feed.state();\n//     }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//   });\n// });\n\n// describe(\"The feed.data() function\", () => {\n//   // INVALID_FEED_STATE tested through the connection cycle above\n//   it(\"should throw if destroyed\", () => {\n//     const harness = harnessFactory();\n//     const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//     feed.destroy();\n//     expect(() => {\n//       feed.data();\n//     }).toThrow(new Error(\"DESTROYED: The feed object has been destroyed.\"));\n//   });\n// });\n\n// /*\n\n// Transport-initiated operations.\n\n// Transport operations that are the direct result of an app-initiated operation\n// are tested above (but not unexpected messages).\n\n// Tested only under the default configuration; alternative configurations are\n// tested above.\n\n// Transport-initiated operations tested here include:\n\n//   - Violation of the transport requirements (transportError)\n//   - Transport disconnect event generated internally (disconnect)\n//   - Transport message event that violates the spec (client badServerMessage)\n//   - Transport message event with ViolationResponse (client badClientMessage)\n//   - Transport message event with ActionRevelation (feed action)\n//   - Transport message event with FeedTermination (feed close)\n\n// For each result path, test:\n\n//   - Client and feed state function return values (listed above)\n//   - Client and feed events\n//   - Transport calls\n//   - Callbacks\n\n// */\n\n// describe(\"if the transport violates a library requirement\", () => {\n//   // State functions - N/A\n\n//   // Events\n\n//   it(\"should emit transportError on the client\", () => {\n//     // Just test one unexpected behavior - unit tests handle the rest\n//     const harness = harnessFactory();\n//     const clientListener = harness.createClientListener();\n//     harness.transport.emit(\"disconnect\"); // Unexpected\n//     expect(clientListener.connecting.calls.count()).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(0);\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//     expect(clientListener.transportError.calls.count()).toBe(1);\n//     expect(clientListener.transportError.calls.argsFor(0).length).toBe(1);\n//     expect(clientListener.transportError.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(clientListener.transportError.calls.argsFor(0)[0].message).toBe(\n//       \"UNEXPECTED_EVENT: Transport emitted a  'disconnect' event when the previous emission was 'disconnect'.\"\n//     );\n//   });\n\n//   // Transport calls - N/A\n\n//   // Callbacks - N/A\n// });\n\n// describe(\"if the transport unexpectedly disconnects\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n//   let harness;\n//   let feedDesiredClosed;\n//   let feedClosed;\n//   let feedOpening;\n//   let feedOpen;\n//   let feedClosing;\n//   beforeEach(async () => {\n//     // Set up a connected client and feeds in all states\n//     harness = harnessFactory();\n//     await harness.connectClient();\n\n//     feedDesiredClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n\n//     feedClosed = harness.client.feed(\"SomeFeed2\", { Feed: \"Arg\" });\n//     feedClosed.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: false,\n//         FeedName: \"SomeFeed2\",\n//         FeedArgs: { Feed: \"Arg\" },\n//         ErrorCode: \"SOME_ERROR_CODE\",\n//         ErrorData: { Error: \"Data\" }\n//       })\n//     );\n\n//     feedOpening = harness.client.feed(\"SomeFeed3\", { Feed: \"Arg\" });\n//     feedOpening.desireOpen();\n\n//     feedOpen = harness.client.feed(\"SomeFeed4\", { Feed: \"Arg\" });\n//     feedOpen.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: true,\n//         FeedName: \"SomeFeed4\",\n//         FeedArgs: { Feed: \"Arg\" },\n//         FeedData: { Feed: \"Data\" }\n//       })\n//     );\n\n//     feedClosing = harness.client.feed(\"SomeFeed5\", { Feed: \"Arg\" });\n//     feedClosing.desireOpen();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"FeedOpenResponse\",\n//         Success: false,\n//         FeedName: \"SomeFeed5\",\n//         FeedArgs: { Feed: \"Arg\" },\n//         FeedData: { Feed: \"Data\" }\n//       })\n//     );\n//     feedClosing.desireClosed();\n//     feedClosing.desireOpen();\n\n//     await promisify(process.nextTick)(); // Move past queued events\n//   });\n\n//   // State functions\n\n//   it(\"should update state functions\", () => {\n//     // Check state functions\n//     expect(harness.client.state()).toBe(\"connected\");\n//     expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//     expect(feedDesiredClosed.desiredState()).toBe(\"closed\");\n//     expect(feedDesiredClosed.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedDesiredClosed.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedClosed.desiredState()).toBe(\"open\");\n//     expect(feedClosed.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedClosed.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedOpening.desiredState()).toBe(\"open\");\n//     expect(feedOpening.state()).toBe(\"opening\");\n//     expect(() => {\n//       feedOpening.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedOpen.desiredState()).toBe(\"open\");\n//     expect(feedOpen.state()).toBe(\"open\");\n//     expect(feedOpen.data()).toEqual({ Feed: \"Data\" });\n//     expect(feedClosing.desiredState()).toBe(\"open\");\n//     expect(feedClosing.state()).toBe(\"opening\");\n//     expect(() => {\n//       feedClosing.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//     // Have the transport disconnect\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//     // Check state functions\n//     expect(harness.client.state()).toBe(\"disconnected\");\n//     expect(() => {\n//       harness.client.id();\n//     }).toThrow(new Error(\"INVALID_STATE: Not connected.\"));\n//     expect(feedDesiredClosed.desiredState()).toBe(\"closed\");\n//     expect(feedDesiredClosed.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedDesiredClosed.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedClosed.desiredState()).toBe(\"open\");\n//     expect(feedClosed.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedClosed.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedOpening.desiredState()).toBe(\"open\");\n//     expect(feedOpening.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedOpening.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedOpen.desiredState()).toBe(\"open\");\n//     expect(feedOpen.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedOpen.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     expect(feedClosing.desiredState()).toBe(\"open\");\n//     expect(feedClosing.state()).toBe(\"closed\");\n//     expect(() => {\n//       feedClosing.data();\n//     }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//   });\n\n//   // Events\n\n//   it(\"should emit events\", async () => {\n//     // Create listeners\n//     const clientListener = harness.createClientListener();\n//     const feedDesiredClosedListener = harness.createFeedListener(\n//       feedDesiredClosed\n//     );\n//     const feedClosedListener = harness.createFeedListener(feedClosed);\n//     const feedOpeningListener = harness.createFeedListener(feedOpening);\n//     const feedOpenListener = harness.createFeedListener(feedOpen);\n//     const feedClosingListener = harness.createFeedListener(feedClosing);\n\n//     // Have the transport disconnect\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//     await promisify(process.nextTick)();\n\n//     // Check events\n//     expect(clientListener.connecting.calls.count()).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(1);\n//     expect(clientListener.disconnect.calls.argsFor(0).length).toBe(1);\n//     expect(clientListener.disconnect.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(clientListener.disconnect.calls.argsFor(0)[0].message).toBe(\n//       \"FAILURE: ...\"\n//     );\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//     expect(clientListener.transportError.calls.count()).toBe(0);\n\n//     expect(feedDesiredClosedListener.opening.calls.count()).toBe(0);\n//     expect(feedDesiredClosedListener.open.calls.count()).toBe(0);\n//     expect(feedDesiredClosedListener.close.calls.count()).toBe(0);\n//     expect(feedDesiredClosedListener.action.calls.count()).toBe(0);\n\n//     expect(feedClosedListener.opening.calls.count()).toBe(0);\n//     expect(feedClosedListener.open.calls.count()).toBe(0);\n//     expect(feedClosedListener.close.calls.count()).toBe(1);\n//     expect(feedClosedListener.close.calls.argsFor(0).length).toBe(1);\n//     expect(feedClosedListener.close.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(feedClosedListener.close.calls.argsFor(0)[0].message).toBe(\n//       \"DISCONNECTED: The transport disconnected.\"\n//     );\n//     expect(feedClosedListener.action.calls.count()).toBe(0);\n\n//     expect(feedOpeningListener.opening.calls.count()).toBe(0);\n//     expect(feedOpeningListener.open.calls.count()).toBe(0);\n//     expect(feedOpeningListener.close.calls.count()).toBe(1);\n//     expect(feedOpeningListener.close.calls.argsFor(0).length).toBe(1);\n//     expect(feedOpeningListener.close.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(feedOpeningListener.close.calls.argsFor(0)[0].message).toBe(\n//       \"DISCONNECTED: The transport disconnected.\"\n//     );\n//     expect(feedOpeningListener.action.calls.count()).toBe(0);\n\n//     expect(feedOpenListener.opening.calls.count()).toBe(0);\n//     expect(feedOpenListener.open.calls.count()).toBe(0);\n//     expect(feedOpenListener.close.calls.count()).toBe(1);\n//     expect(feedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//     expect(feedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(feedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//       \"DISCONNECTED: The transport disconnected.\"\n//     );\n//     expect(feedOpenListener.action.calls.count()).toBe(0);\n\n//     expect(feedClosingListener.opening.calls.count()).toBe(0);\n//     expect(feedClosingListener.open.calls.count()).toBe(0);\n//     expect(feedClosingListener.close.calls.count()).toBe(1);\n//     expect(feedClosingListener.close.calls.argsFor(0).length).toBe(1);\n//     expect(feedClosingListener.close.calls.argsFor(0)[0]).toEqual(\n//       jasmine.any(Error)\n//     );\n//     expect(feedClosingListener.close.calls.argsFor(0)[0].message).toBe(\n//       \"DISCONNECTED: The transport disconnected.\"\n//     );\n//     expect(feedClosingListener.action.calls.count()).toBe(0);\n//   });\n\n//   // Transport calls - N/A (reconnecting tested above)\n\n//   // Callbacks\n\n//   it(\"should call client.action() callbacks\", async () => {\n//     harness = harnessFactory();\n//     await harness.connectClient();\n//     const cb = jasmine.createSpy();\n//     harness.client.action(\"SomeAction\", { Action: \"Arg\" }, cb);\n\n//     // Have the transport disconnect\n//     harness.transport.state.and.returnValue(\"disconnected\");\n//     harness.transport.emit(\"disconnect\", new Error(\"FAILURE: ...\"));\n\n//     expect(cb.calls.count()).toBe(1);\n//     expect(cb.calls.argsFor(0).length).toBe(1);\n//     expect(cb.calls.argsFor(0)[0]).toEqual(jasmine.any(Error));\n//     expect(cb.calls.argsFor(0)[0].message).toBe(\n//       \"DISCONNECTED: The transport disconnected.\"\n//     );\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// /*\n\n// All of the valid/expected message cases are tested thoroughly above, except\n// for ViolationResponse, ActionRevelation, and FeedTermination.\n\n// Tested here:\n//   Structurally invalid server messages\n//     Invalid JSON\n//     Schema failure\n//   Sequentially invalid server messages\n//     HandshakeResponse\n//     ActionResponse\n//     FeedOpenResponse\n//     FeedCloseResponse\n//   ViolationResponse messages\n//   ActionRevelation messages\n//   FeedTermination messages\n\n// */\n\n// describe(\"structurally invalid server messages\", () => {\n//   describe(\"if the message is invalid JSON\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\"message\", \"bad json\");\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"INVALID_MESSAGE: Invalid JSON or schema violation.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"if schema validation fails\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\"message\", \"{}\");\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"INVALID_MESSAGE: Invalid JSON or schema violation.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n// });\n\n// describe(\"sequentially invalid server messages\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   describe(\"unexpected HandshakeResponse - before Handshake\", () => {\n//     // Can't test, since Handshake is sent synchronously on transport connect\n//   });\n\n//   describe(\"unexpected HandshakeResponse - another after HandshakeResponse\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"HandshakeResponse\",\n//           Success: true,\n//           Version: \"0.1\",\n//           ClientId: \"SOME_CLIENT_ID\"\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected HandshakeResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected ActionResponse - before HandshakeResponse\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionResponse\",\n//           CallbackId: \"SOME_CALLBACK_ID\",\n//           Success: true,\n//           ActionData: { Action: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected ActionResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected ActionResponse - unrecognized callback id\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionResponse\",\n//           CallbackId: \"SOME_CALLBACK_ID\",\n//           Success: true,\n//           ActionData: { Action: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected ActionResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedOpenResponse - before HandshakeResponse\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SOME_FEED_NAME\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedOpenResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedOpenResponse - server feed was understood to be closed\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SOME_FEED_NAME\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedOpenResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedOpenResponse - server feed was understood to be open\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SOME_FEED_NAME\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedOpenResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedOpenResponse - server feed was understood to be closing\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n//       feed.desireClosed();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SOME_FEED_NAME\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedOpenResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedCloseResponse - before HandshakeResponse\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedCloseResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedCloseResponse - server feed was understood to be closed\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedCloseResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedCloseResponse - server feed was understood to be opening\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedCloseResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedCloseResponse - server feed was understood to be open\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedCloseResponse\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedCloseResponse.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected ActionRevelation - before HandshakeResponse\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionRevelation\",\n//           ActionName: \"SomeAction\",\n//           ActionData: { Action: \"Data\" },\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedDeltas: [],\n//           FeedMd5: \"123451234512345123451234\"\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected ActionRevelation.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected ActionRevelation - server feed was understood to be closed\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionRevelation\",\n//           ActionName: \"SomeAction\",\n//           ActionData: { Action: \"Data\" },\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedDeltas: [],\n//           FeedMd5: \"123451234512345123451234\"\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected ActionRevelation.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected ActionRevelation - server feed was understood to be opening\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"ActionRevelation\",\n//           ActionName: \"SomeAction\",\n//           ActionData: { Action: \"Data\" },\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedDeltas: [],\n//           FeedMd5: \"123451234512345123451234\"\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected ActionRevelation.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedTermination - before HandshakeResponse\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", () => {\n//       const harness = harnessFactory();\n//       harness.client.connect();\n//       harness.transport.state.and.returnValue(\"connecting\");\n//       harness.transport.emit(\"connecting\");\n//       harness.transport.state.and.returnValue(\"connected\");\n//       harness.transport.emit(\"connect\");\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedTermination.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedTermination - server feed was understood to be closed\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedTermination.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"unexpected FeedTermination - server feed was understood to be opening\", () => {\n//     // State functions - N/A\n\n//     // Events\n\n//     it(\"should emit badServerMessage\", async () => {\n//       const harness = harnessFactory();\n//       await harness.connectClient();\n//       const feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       const clientListener = harness.createClientListener();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0).length).toBe(1);\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(clientListener.badServerMessage.calls.argsFor(0)[0].message).toBe(\n//         \"UNEXPECTED_MESSAGE: Unexpected FeedTermination.\"\n//       );\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls - N/A\n\n//     // Callbacks - N/A\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"Structurally/sequentially valid ViolationResponse message\", () => {\n//   // State functions - N/A\n\n//   // Events - N/A\n\n//   it(\"should emit badClientMessage\", async () => {\n//     const harness = harnessFactory();\n//     await harness.connectClient();\n//     const clientListener = harness.createClientListener();\n//     harness.transport.emit(\n//       \"message\",\n//       JSON.stringify({\n//         MessageType: \"ViolationResponse\",\n//         Diagnostics: { Diagnostic: \"Data\" }\n//       })\n//     );\n\n//     expect(clientListener.connecting.calls.count()).toBe(0);\n//     expect(clientListener.connect.calls.count()).toBe(0);\n//     expect(clientListener.disconnect.calls.count()).toBe(0);\n//     expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//     expect(clientListener.badClientMessage.calls.count()).toBe(1);\n//     expect(clientListener.badClientMessage.calls.argsFor(0).length).toBe(1);\n//     expect(clientListener.badClientMessage.calls.argsFor(0)[0]).toEqual({\n//       Diagnostic: \"Data\"\n//     });\n//     expect(clientListener.transportError.calls.count()).toBe(0);\n//   });\n\n//   // Transport calls - N/A\n\n//   // Callbacks - N/A\n// });\n\n// describe(\"Structurally/sequentially valid ActionRevelation message\", () => {\n//   beforeEach(() => {\n//     jasmine.clock().install();\n//   });\n\n//   describe(\"if the server feed is open\", () => {\n//     let harness;\n//     let feedWantedOpen;\n//     let feedWantedClosed;\n//     beforeEach(async () => {\n//       harness = harnessFactory();\n//       await harness.connectClient();\n//       feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n\n//       await promisify(process.nextTick)(); // Move past queued events\n//     });\n\n//     describe(\"if there is an invalid feed delta\", () => {\n//       // State functions\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"open\");\n//         expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Have the transport emit a ActionRevelation with a bad delta\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"an\", \"invalid\", \"path\"],\n//                 Value: 123\n//               }\n//             ]\n//           })\n//         );\n\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       // Events - client and feed\n\n//       it(\"events\", async () => {\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Have the transport emit a ActionRevelation with a bad delta\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"an\", \"invalid\", \"path\"],\n//                 Value: 123\n//               }\n//             ]\n//           })\n//         );\n\n//         await promisify(process.nextTick)();\n\n//         // Check client events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//         expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(\n//           clientListener.badServerMessage.calls.argsFor(0)[0].message\n//         ).toBe(\n//           \"INVALID_DELTA: Received ActionRevelation with contextually invalid feed delta.\"\n//         );\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n\n//         // Check feed events\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//         expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//         expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//           \"BAD_ACTION_REVELATION: The server passed an invalid feed delta.\"\n//         );\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       // Transport calls\n\n//       it(\"transport calls\", () => {\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a ActionRevelation with a bad delta\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"an\", \"invalid\", \"path\"],\n//                 Value: 123\n//               }\n//             ]\n//           })\n//         );\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(1); // FeedClose\n//         expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//           JSON.stringify({\n//             MessageType: \"FeedClose\",\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" }\n//           })\n//         );\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       // Callbacks - N/A\n//     });\n\n//     describe(\"if there is an invalid feed data hash\", () => {\n//       // State functions\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"open\");\n//         expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Have the transport emit a ActionRevelation with a bad hash\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"validpath\"],\n//                 Value: 123\n//               }\n//             ],\n//             FeedMd5: \"123456789012345678901234\"\n//           })\n//         );\n\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedOpen.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       // Events - client and feed\n\n//       it(\"events\", async () => {\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n\n//         // Have the transport emit a ActionRevelation with a bad hash\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"validpath\"],\n//                 Value: 123\n//               }\n//             ],\n//             FeedMd5: \"123456789012345678901234\"\n//           })\n//         );\n\n//         await promisify(process.nextTick)();\n\n//         // Check client events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(1);\n//         expect(clientListener.badServerMessage.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(\n//           clientListener.badServerMessage.calls.argsFor(0)[0].message\n//         ).toBe(\"INVALID_HASH: Feed data MD5 verification failed.\");\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n\n//         // Check feed events\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//         expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//         expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//           jasmine.any(Error)\n//         );\n//         expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//           \"BAD_ACTION_REVELATION: Hash verification failed.\"\n//         );\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       // Transport calls\n\n//       it(\"transport calls\", () => {\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a ActionRevelation with a bad hash\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"validpath\"],\n//                 Value: 123\n//               }\n//             ],\n//             FeedMd5: \"123456789012345678901234\"\n//           })\n//         );\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(1); // FeedClose\n//         expect(harness.transport.send.calls.argsFor(0)[0]).toBe(\n//           JSON.stringify({\n//             MessageType: \"FeedClose\",\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" }\n//           })\n//         );\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       // Callbacks - N/A\n//     });\n\n//     describe(\"if the revelation is valid\", () => {\n//       // State functions\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"open\");\n//         expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Have the transport emit a valid ActionRevelation\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"Feed\"],\n//                 Value: \"Data2\"\n//               }\n//             ],\n//             FeedMd5: \"wh+CI4D0VYuSbmN8BzeSxA==\"\n//           })\n//         );\n\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//         expect(feedWantedOpen.state()).toBe(\"open\");\n//         expect(feedWantedOpen.data()).toEqual({ Feed: \"Data2\" });\n//         expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//         expect(feedWantedClosed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feedWantedClosed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       // Events - client and feed\n\n//       it(\"events\", async () => {\n//         const clientListener = harness.createClientListener();\n//         const feedWantedOpenListener = harness.createFeedListener(\n//           feedWantedOpen\n//         );\n//         const feedWantedClosedListener = harness.createFeedListener(\n//           feedWantedClosed\n//         );\n//         const actionNameSpy = jasmine.createSpy();\n//         feedWantedOpen.on(\"action:SomeAction\", actionNameSpy);\n\n//         // Have the transport emit a valid ActionRevelation\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"Feed\"],\n//                 Value: \"Data2\"\n//               }\n//             ],\n//             FeedMd5: \"wh+CI4D0VYuSbmN8BzeSxA==\"\n//           })\n//         );\n\n//         await promisify(process.nextTick)();\n\n//         // Check client events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n\n//         // Check feed events\n//         expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.close.calls.count()).toBe(0);\n//         expect(feedWantedOpenListener.action.calls.count()).toBe(1);\n//         expect(feedWantedOpenListener.action.calls.argsFor(0).length).toBe(4);\n//         expect(feedWantedOpenListener.action.calls.argsFor(0)[0]).toBe(\n//           \"SomeAction\"\n//         );\n//         expect(feedWantedOpenListener.action.calls.argsFor(0)[1]).toEqual({\n//           Action: \"Data\"\n//         });\n//         expect(feedWantedOpenListener.action.calls.argsFor(0)[2]).toEqual({\n//           Feed: \"Data2\"\n//         });\n//         expect(feedWantedOpenListener.action.calls.argsFor(0)[3]).toEqual({\n//           Feed: \"Data\"\n//         });\n//         expect(actionNameSpy.calls.count()).toBe(1);\n//         expect(actionNameSpy.calls.argsFor(0).length).toBe(3);\n//         expect(actionNameSpy.calls.argsFor(0)[0]).toEqual({\n//           Action: \"Data\"\n//         });\n//         expect(actionNameSpy.calls.argsFor(0)[1]).toEqual({\n//           Feed: \"Data2\"\n//         });\n//         expect(actionNameSpy.calls.argsFor(0)[2]).toEqual({\n//           Feed: \"Data\"\n//         });\n//         expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//         expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//       });\n\n//       // Transport calls\n\n//       it(\"transport calls\", () => {\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a valid ActionRevelation\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"Feed\"],\n//                 Value: \"Data2\"\n//               }\n//             ],\n//             FeedMd5: \"wh+CI4D0VYuSbmN8BzeSxA==\"\n//           })\n//         );\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       // Callbacks - N/A\n//     });\n//   });\n\n//   describe(\"if the server feed is closing\", () => {\n//     let harness;\n//     let feed;\n//     beforeEach(async () => {\n//       harness = harnessFactory();\n//       await harness.connectClient();\n//       feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n//       feed.desireClosed();\n//     });\n\n//     describe(\"if there is an invalid feed delta\", () => {\n//       // State functions\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Have the transport emit a ActionRevelation with a bad delta\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"an\", \"invalid\", \"path\"],\n//                 Value: 123\n//               }\n//             ]\n//           })\n//         );\n\n//         // Check state functions\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       // Events - client and feed\n\n//       it(\"events\", () => {\n//         const clientListener = harness.createClientListener();\n//         const feedListener = harness.createFeedListener(feed);\n\n//         // Have the transport emit a ActionRevelation with a bad delta\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"an\", \"invalid\", \"path\"],\n//                 Value: 123\n//               }\n//             ]\n//           })\n//         );\n\n//         // Check client events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0); // Message discarded due to closing - never processed\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n\n//         // Check feed events\n//         expect(feedListener.opening.calls.count()).toBe(0);\n//         expect(feedListener.open.calls.count()).toBe(0);\n//         expect(feedListener.close.calls.count()).toBe(0);\n//         expect(feedListener.action.calls.count()).toBe(0);\n//       });\n\n//       // Transport calls\n\n//       it(\"transport calls\", () => {\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a ActionRevelation with a bad delta\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"an\", \"invalid\", \"path\"],\n//                 Value: 123\n//               }\n//             ]\n//           })\n//         );\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0); // No need to FeedClose\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       // Callbacks - N/A\n//     });\n\n//     describe(\"if there is an invalid feed data hash\", () => {\n//       // State functions\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Have the transport emit a ActionRevelation with a bad hash\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"validpath\"],\n//                 Value: 123\n//               }\n//             ],\n//             FeedMd5: \"123456789012345678901234\"\n//           })\n//         );\n\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       // Events - client and feed\n\n//       it(\"events\", () => {\n//         const clientListener = harness.createClientListener();\n//         const feedListener = harness.createFeedListener(feed);\n\n//         // Have the transport emit a ActionRevelation with a bad hash\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"validpath\"],\n//                 Value: 123\n//               }\n//             ],\n//             FeedMd5: \"123456789012345678901234\"\n//           })\n//         );\n\n//         // Check client events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0); // Discarded before process\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n\n//         // Check feed events\n//         expect(feedListener.opening.calls.count()).toBe(0);\n//         expect(feedListener.open.calls.count()).toBe(0);\n//         expect(feedListener.close.calls.count()).toBe(0);\n//         expect(feedListener.action.calls.count()).toBe(0);\n//       });\n\n//       // Transport calls\n\n//       it(\"transport calls\", () => {\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a ActionRevelation with a bad hash\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"validpath\"],\n//                 Value: 123\n//               }\n//             ],\n//             FeedMd5: \"123456789012345678901234\"\n//           })\n//         );\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0); // No need to FeedClose\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       // Callbacks - N/A\n//     });\n\n//     describe(\"if the revelation is valid\", () => {\n//       // State functions\n\n//       it(\"state functions\", () => {\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n\n//         // Have the transport emit a valid ActionRevelation\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"Feed\"],\n//                 Value: \"Data2\"\n//               }\n//             ],\n//             FeedMd5: \"wh+CI4D0VYuSbmN8BzeSxA==\"\n//           })\n//         );\n\n//         // Check state functions\n//         expect(harness.client.state()).toBe(\"connected\");\n//         expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//         expect(feed.desiredState()).toBe(\"closed\");\n//         expect(feed.state()).toBe(\"closed\");\n//         expect(() => {\n//           feed.data();\n//         }).toThrow(\n//           new Error(\"INVALID_FEED_STATE: The feed object is not open.\")\n//         );\n//       });\n\n//       // Events - client and feed\n\n//       it(\"events\", () => {\n//         const clientListener = harness.createClientListener();\n//         const feedListener = harness.createFeedListener(feed);\n//         const actionNameSpy = jasmine.createSpy();\n//         feed.on(\"action:SomeAction\", actionNameSpy);\n\n//         // Have the transport emit a valid ActionRevelation\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"Feed\"],\n//                 Value: \"Data2\"\n//               }\n//             ],\n//             FeedMd5: \"wh+CI4D0VYuSbmN8BzeSxA==\"\n//           })\n//         );\n\n//         // Check client events\n//         expect(clientListener.connecting.calls.count()).toBe(0);\n//         expect(clientListener.connect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.count()).toBe(0);\n//         expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//         expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//         expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//         expect(clientListener.transportError.calls.count()).toBe(0);\n\n//         // Check feed events\n//         expect(feedListener.opening.calls.count()).toBe(0);\n//         expect(feedListener.open.calls.count()).toBe(0);\n//         expect(feedListener.close.calls.count()).toBe(0);\n//         expect(feedListener.action.calls.count()).toBe(0);\n//         expect(actionNameSpy.calls.count()).toBe(0);\n//       });\n\n//       // Transport calls\n\n//       it(\"transport calls\", () => {\n//         harness.transport.spyClear();\n\n//         // Have the transport emit a valid ActionRevelation\n//         harness.transport.emit(\n//           \"message\",\n//           JSON.stringify({\n//             MessageType: \"ActionRevelation\",\n//             ActionName: \"SomeAction\",\n//             ActionData: { Action: \"Data\" },\n//             FeedName: \"SomeFeed\",\n//             FeedArgs: { Feed: \"Arg\" },\n//             FeedDeltas: [\n//               {\n//                 Operation: \"Set\",\n//                 Path: [\"Feed\"],\n//                 Value: \"Data2\"\n//               }\n//             ],\n//             FeedMd5: \"wh+CI4D0VYuSbmN8BzeSxA==\"\n//           })\n//         );\n\n//         // Check transport calls\n//         expect(harness.transport.connect.calls.count()).toBe(0);\n//         expect(harness.transport.send.calls.count()).toBe(0);\n//         expect(harness.transport.disconnect.calls.count()).toBe(0);\n//         expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//       });\n\n//       // Callbacks - N/A\n//     });\n//   });\n\n//   afterEach(() => {\n//     jasmine.clock().uninstall();\n//   });\n// });\n\n// describe(\"Structurally/sequentially valid FeedTermination message\", () => {\n//   describe(\"when the server feed is open\", () => {\n//     let harness;\n//     let feedWantedOpen;\n//     let feedWantedClosed;\n//     beforeEach(async () => {\n//       harness = harnessFactory();\n//       await harness.connectClient();\n//       feedWantedOpen = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feedWantedOpen.desireOpen();\n//       feedWantedClosed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n//       await promisify(process.nextTick)(); // Move past queued events\n//     });\n//     // State functions\n\n//     it(\"state functions\", () => {\n//       // Check state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"open\");\n//       expect(feedWantedOpen.data()).toEqual({ Feed: \"Data\" });\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Have the transport emit a FeedTermination\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       // Check state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feedWantedOpen.desiredState()).toBe(\"open\");\n//       expect(feedWantedOpen.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedOpen.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//       expect(feedWantedClosed.desiredState()).toBe(\"closed\");\n//       expect(feedWantedClosed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feedWantedClosed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     // Events - client and feed\n\n//     it(\"events\", async () => {\n//       const clientListener = harness.createClientListener();\n//       const feedWantedOpenListener = harness.createFeedListener(feedWantedOpen);\n//       const feedWantedClosedListener = harness.createFeedListener(\n//         feedWantedClosed\n//       );\n\n//       // Have the transport emit a FeedTermination\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       await promisify(process.nextTick)();\n\n//       // Check client events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n\n//       // Check feed events\n//       expect(feedWantedOpenListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.open.calls.count()).toBe(0);\n//       expect(feedWantedOpenListener.close.calls.count()).toBe(1);\n//       expect(feedWantedOpenListener.close.calls.argsFor(0).length).toBe(1);\n//       expect(feedWantedOpenListener.close.calls.argsFor(0)[0]).toEqual(\n//         jasmine.any(Error)\n//       );\n//       expect(feedWantedOpenListener.close.calls.argsFor(0)[0].message).toBe(\n//         \"TERMINATED: The server terminated the feed.\"\n//       );\n//       expect(feedWantedOpenListener.action.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.opening.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.open.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.close.calls.count()).toBe(0);\n//       expect(feedWantedClosedListener.action.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls\n\n//     it(\"transport calls\", () => {\n//       harness.transport.spyClear();\n\n//       // Have the transport emit a FeedTermination\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       // Check transport calls\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n\n//     // Callbacks - N/A\n//   });\n\n//   describe(\"when the server feed is closing\", () => {\n//     let harness;\n//     let feed;\n//     beforeEach(async () => {\n//       harness = harnessFactory();\n//       await harness.connectClient();\n//       feed = harness.client.feed(\"SomeFeed\", { Feed: \"Arg\" });\n//       feed.desireOpen();\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedOpenResponse\",\n//           Success: true,\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           FeedData: { Feed: \"Data\" }\n//         })\n//       );\n//       feed.desireClosed();\n//     });\n//     // State functions\n\n//     it(\"state functions\", () => {\n//       // Check state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feed.desiredState()).toBe(\"closed\");\n//       expect(feed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n\n//       // Have the transport emit a FeedTermination\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       // Check state functions\n//       expect(harness.client.state()).toBe(\"connected\");\n//       expect(harness.client.id()).toBe(\"SOME_CLIENT_ID\");\n//       expect(feed.desiredState()).toBe(\"closed\");\n//       expect(feed.state()).toBe(\"closed\");\n//       expect(() => {\n//         feed.data();\n//       }).toThrow(new Error(\"INVALID_FEED_STATE: The feed object is not open.\"));\n//     });\n\n//     // Events - client and feed\n\n//     it(\"events\", () => {\n//       const clientListener = harness.createClientListener();\n//       const feedListener = harness.createFeedListener(feed);\n\n//       // Have the transport emit a FeedTermination\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       // Check client events\n//       expect(clientListener.connecting.calls.count()).toBe(0);\n//       expect(clientListener.connect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.count()).toBe(0);\n//       expect(clientListener.disconnect.calls.argsFor(0).length).toBe(0);\n//       expect(clientListener.badServerMessage.calls.count()).toBe(0);\n//       expect(clientListener.badClientMessage.calls.count()).toBe(0);\n//       expect(clientListener.transportError.calls.count()).toBe(0);\n\n//       // Check feed events\n//       expect(feedListener.opening.calls.count()).toBe(0);\n//       expect(feedListener.open.calls.count()).toBe(0);\n//       expect(feedListener.close.calls.count()).toBe(0);\n//       expect(feedListener.action.calls.count()).toBe(0);\n//     });\n\n//     // Transport calls\n\n//     it(\"transport calls\", () => {\n//       harness.transport.spyClear();\n\n//       // Have the transport emit a FeedTermination\n//       harness.transport.emit(\n//         \"message\",\n//         JSON.stringify({\n//           MessageType: \"FeedTermination\",\n//           FeedName: \"SomeFeed\",\n//           FeedArgs: { Feed: \"Arg\" },\n//           ErrorCode: \"SOME_ERROR_CODE\",\n//           ErrorData: { Error: \"Data\" }\n//         })\n//       );\n\n//       // Check transport calls\n//       expect(harness.transport.connect.calls.count()).toBe(0);\n//       expect(harness.transport.send.calls.count()).toBe(0);\n//       expect(harness.transport.disconnect.calls.count()).toBe(0);\n//       expect(harness.transport.state.calls.count() >= 0).toBe(true);\n//     });\n\n//     // Callbacks - N/A\n//   });\n// });\n"],"sourceRoot":""}